{% extends 'base.html' %}

{% block title %}Image Watermark - {{ SITE_NAME }}{% endblock %}

{% block content %}
<div class="card">
    <h1 class="card-title">Image Watermark</h1>
    <p>Add text or image watermark to your images</p>
    
    {% if error %}
    <div class="alert alert-error">{{ error }}</div>
    {% endif %}
    
    <div class="privacy-notice">
        <p>
            <span>üîí</span>
            <span><strong>Privacy Notice:</strong> Your files are processed securely and are <strong>not stored</strong> on our servers.</span>
        </p>
    </div>
    
    <form method="post" enctype="multipart/form-data" id="watermarkForm">
        {% csrf_token %}
        <div class="form-group">
            <label class="form-label">Select Image File</label>
            <div class="file-upload-area" id="uploadArea">
                <input type="file" name="image" id="image" accept="image/*,.heic,.heif,image/heic,image/heif" required>
                <div id="uploadContent">
                    <p style="margin-top: 1rem; font-size: 1.1rem;">üìÅ Click to select or drag and drop</p>
                    <p style="color: var(--text-secondary); font-size: 0.9rem; margin-top: 0.5rem;">Supports: JPG, JPEG, PNG, WebP, SVG, BMP, TIFF, GIF, ICO, AVIF, HEIC</p>
                </div>
            </div>
        </div>
        
        <div class="form-group" style="margin-top: 1.5rem;">
            <label class="form-label">Watermark Type</label>
            <div class="grid grid-2 gap-md">
                <label style="display: flex; align-items: center; padding: 1rem; border: 2px solid var(--border-color); border-radius: 6px; cursor: pointer;" class="gap-xs">
                    <input type="radio" name="watermark_type" value="text" checked onchange="toggleWatermarkType()">
                    <span>üìù Text Watermark</span>
                </label>
                <label style="display: flex; align-items: center; padding: 1rem; border: 2px solid var(--border-color); border-radius: 6px; cursor: pointer;" class="gap-xs">
                    <input type="radio" name="watermark_type" value="image" onchange="toggleWatermarkType()">
                    <span>üñºÔ∏è Image Watermark</span>
                </label>
            </div>
        </div>
        
        <div id="textWatermarkOptions">
            <div class="form-group" style="margin-top: 1.5rem;">
                <label class="form-label" for="watermark_text">Watermark Text</label>
                <input type="text" class="form-control" id="watermark_text" name="watermark_text" placeholder="Enter watermark text" maxlength="100">
            </div>
            
            <div class="form-group" style="margin-top: 1rem;">
                <label class="form-label" for="font_size">Font Size</label>
                <input type="number" class="form-control" id="font_size" name="font_size" min="12" max="200" value="36">
            </div>
            
            <div class="form-group" style="margin-top: 1rem;">
                <label class="form-label" for="color">Text Color</label>
                <input type="hidden" id="color" name="color" value="#FFFFFF">
                <div id="watermarkColorPicker" style="position: relative; max-width: 300px;">
                    <div id="watermarkColorSquare" style="position: relative; width: 200px; height: 200px; border-radius: 8px; overflow: hidden; cursor: crosshair; box-shadow: 0 2px 8px rgba(0,0,0,0.15); margin-bottom: 0.5rem;">
                        <canvas id="watermarkColorCanvas" style="width: 100%; height: 100%; display: block;"></canvas>
                        <div id="watermarkColorHandle" style="position: absolute; width: 16px; height: 16px; border: 2px solid white; border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.3); transform: translate(-50%, -50%); pointer-events: none; z-index: 10;"></div>
                    </div>
                    <div id="watermarkHueSlider" style="position: relative; width: 200px; height: 30px; border-radius: 8px; overflow: hidden; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 0.5rem;">
                        <canvas id="watermarkHueCanvas" style="width: 100%; height: 100%; display: block;"></canvas>
                        <div id="watermarkHueHandle" style="position: absolute; top: 50%; width: 16px; height: 16px; border: 2px solid white; border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.3); transform: translate(-50%, -50%); pointer-events: none; z-index: 10; background: rgba(255,255,255,0.3);"></div>
                    </div>
                    <div style="display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem;">
                        <input type="text" id="watermarkHexInput" class="form-control" placeholder="#FFFFFF" maxlength="7" style="flex: 1; font-family: monospace; max-width: 120px;">
                        <div id="watermarkColorPreview" style="width: 50px; height: 40px; border-radius: 6px; border: 2px solid var(--border-color); background: #FFFFFF; flex-shrink: 0;"></div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; max-width: 200px;">
                        <div>
                            <label style="font-size: 0.8rem; color: var(--text-secondary); display: block; margin-bottom: 0.25rem;">R</label>
                            <input type="number" id="watermarkR" min="0" max="255" value="255" class="form-control" style="padding: 0.4rem; font-size: 0.9rem;">
                        </div>
                        <div>
                            <label style="font-size: 0.8rem; color: var(--text-secondary); display: block; margin-bottom: 0.25rem;">G</label>
                            <input type="number" id="watermarkG" min="0" max="255" value="255" class="form-control" style="padding: 0.4rem; font-size: 0.9rem;">
                        </div>
                        <div>
                            <label style="font-size: 0.8rem; color: var(--text-secondary); display: block; margin-bottom: 0.25rem;">B</label>
                            <input type="number" id="watermarkB" min="0" max="255" value="255" class="form-control" style="padding: 0.4rem; font-size: 0.9rem;">
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="imageWatermarkOptions" style="display: none;">
            <div class="form-group" style="margin-top: 1.5rem;">
                <label class="form-label">Watermark Image</label>
                <div class="file-upload-area" style="padding: 1.5rem;">
                    <input type="file" name="watermark_image" id="watermark_image" accept="image/*,.heic,.heif,image/heic,image/heif">
                    <p style="margin-top: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">Upload watermark image (PNG with transparency works best)</p>
                </div>
            </div>
            
            <div class="form-group" style="margin-top: 1rem;">
                <label class="form-label" for="scale">Watermark Size (% of image)</label>
                <input type="range" class="form-control" id="scale" name="scale" min="5" max="50" value="20" 
                       oninput="document.getElementById('scaleValue').textContent = this.value + '%'">
                <div style="display: flex; justify-content: space-between; margin-top: 0.5rem;">
                    <span style="font-size: 0.85rem; color: var(--text-secondary);">Small</span>
                    <span style="font-size: 0.9rem; font-weight: 600;" id="scaleValue">20%</span>
                    <span style="font-size: 0.85rem; color: var(--text-secondary);">Large</span>
                </div>
            </div>
        </div>
        
        <div class="form-group" style="margin-top: 1.5rem;">
            <label class="form-label" for="position">Position</label>
            <select class="form-select" id="position" name="position">
                <option value="top-left">Top Left</option>
                <option value="top-right">Top Right</option>
                <option value="bottom-left">Bottom Left</option>
                <option value="bottom-right" selected>Bottom Right</option>
                <option value="center">Center</option>
            </select>
        </div>
        
        <div class="form-group" style="margin-top: 1rem;">
            <label class="form-label" for="opacity">Opacity</label>
            <input type="range" class="form-control" id="opacity" name="opacity" min="10" max="100" value="50" 
                   oninput="document.getElementById('opacityValue').textContent = this.value + '%'">
            <div style="display: flex; justify-content: space-between; margin-top: 0.5rem;">
                <span style="font-size: 0.85rem; color: var(--text-secondary);">Transparent</span>
                <span style="font-size: 0.9rem; font-weight: 600;" id="opacityValue">50%</span>
                <span style="font-size: 0.85rem; color: var(--text-secondary);">Opaque</span>
            </div>
        </div>
        
        <button type="submit" class="btn btn-primary btn-block" style="margin-top: 1.5rem;">Add Watermark & Download</button>
    </form>
</div>

<a href="{% url 'image_converter:index' %}" class="btn btn-secondary">‚Üê Back to Image Conversion & Editing</a>

{% block extra_js %}
<script>
function toggleWatermarkType() {
    const watermarkType = document.querySelector('input[name="watermark_type"]:checked').value;
    const textOptions = document.getElementById('textWatermarkOptions');
    const imageOptions = document.getElementById('imageWatermarkOptions');
    
    if (watermarkType === 'text') {
        textOptions.style.display = 'block';
        imageOptions.style.display = 'none';
        document.getElementById('watermark_text').required = true;
        document.getElementById('watermark_image').required = false;
    } else {
        textOptions.style.display = 'none';
        imageOptions.style.display = 'block';
        document.getElementById('watermark_text').required = false;
        document.getElementById('watermark_image').required = true;
    }
}

// Color conversion utilities
const ColorConverter = {
    hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    },
    
    rgbToHex(r, g, b) {
        return "#" + [r, g, b].map(x => {
            const hex = x.toString(16);
            return hex.length === 1 ? "0" + hex : hex;
        }).join("");
    },
    
    rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        
        if (max === min) {
            h = s = 0;
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                case g: h = ((b - r) / d + 2) / 6; break;
                case b: h = ((r - g) / d + 4) / 6; break;
            }
        }
        
        return {
            h: Math.round(h * 360),
            s: Math.round(s * 100),
            l: Math.round(l * 100)
        };
    },
    
    hslToRgb(h, s, l) {
        h /= 360;
        s /= 100;
        l /= 100;
        let r, g, b;
        
        if (s === 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }
        
        return {
            r: Math.round(r * 255),
            g: Math.round(g * 255),
            b: Math.round(b * 255)
        };
    }
};

// Watermark Color Picker
class WatermarkColorPicker {
    constructor() {
        this.colorCanvas = document.getElementById('watermarkColorCanvas');
        this.hueCanvas = document.getElementById('watermarkHueCanvas');
        this.colorHandle = document.getElementById('watermarkColorHandle');
        this.hueHandle = document.getElementById('watermarkHueHandle');
        this.hexInput = document.getElementById('watermarkHexInput');
        this.colorPreview = document.getElementById('watermarkColorPreview');
        this.rInput = document.getElementById('watermarkR');
        this.gInput = document.getElementById('watermarkG');
        this.bInput = document.getElementById('watermarkB');
        this.colorInput = document.getElementById('color');
        
        this.hue = 0;
        this.saturation = 0;
        this.brightness = 100;
        this.isDragging = false;
        this.isHueDragging = false;
        
        // Initialize from current color value
        const currentColor = this.colorInput.value || '#FFFFFF';
        this.setColorFromHex(currentColor);
        
        this.init();
    }
    
    init() {
        this.setupCanvases();
        this.setupEventListeners();
        this.updateColor();
    }
    
    setupCanvases() {
        // Fixed size for color square: 200x200
        this.colorCanvas.width = 200;
        this.colorCanvas.height = 200;
        this.drawColorSquare();
        
        // Fixed size for hue slider: 200x30
        this.hueCanvas.width = 200;
        this.hueCanvas.height = 30;
        this.drawHueSlider();
    }
    
    drawColorSquare() {
        const ctx = this.colorCanvas.getContext('2d');
        const size = this.colorCanvas.width;
        
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                const s = (x / size) * 100;
                const v = 100 - (y / size) * 100;
                const rgb = ColorConverter.hslToRgb(this.hue, s, v);
                ctx.fillStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
                ctx.fillRect(x, y, 1, 1);
            }
        }
    }
    
    drawHueSlider() {
        const ctx = this.hueCanvas.getContext('2d');
        const width = this.hueCanvas.width;
        const height = this.hueCanvas.height;
        
        for (let x = 0; x < width; x++) {
            const hue = (x / width) * 360;
            const rgb = ColorConverter.hslToRgb(hue, 100, 50);
            ctx.fillStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
            ctx.fillRect(x, 0, 1, height);
        }
    }
    
    setupEventListeners() {
        // Color square
        this.colorCanvas.addEventListener('mousedown', (e) => this.startDrag(e, true));
        this.colorCanvas.addEventListener('mousemove', (e) => this.onDrag(e, true));
        this.colorCanvas.addEventListener('mouseup', () => this.stopDrag());
        this.colorCanvas.addEventListener('mouseleave', () => this.stopDrag());
        
        this.colorCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.startDrag(e.touches[0], true);
        });
        this.colorCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            this.onDrag(e.touches[0], true);
        });
        this.colorCanvas.addEventListener('touchend', () => this.stopDrag());
        
        // Hue slider
        this.hueCanvas.addEventListener('mousedown', (e) => this.startDrag(e, false));
        this.hueCanvas.addEventListener('mousemove', (e) => this.onDrag(e, false));
        this.hueCanvas.addEventListener('mouseup', () => this.stopDrag());
        this.hueCanvas.addEventListener('mouseleave', () => this.stopDrag());
        
        this.hueCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.startDrag(e.touches[0], false);
        });
        this.hueCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            this.onDrag(e.touches[0], false);
        });
        this.hueCanvas.addEventListener('touchend', () => this.stopDrag());
        
        // Hex input
        this.hexInput.addEventListener('input', (e) => {
            const hex = e.target.value;
            if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                this.setColorFromHex(hex);
            }
        });
        
        // RGB inputs
        [this.rInput, this.gInput, this.bInput].forEach(input => {
            input.addEventListener('input', () => {
                const r = parseInt(this.rInput.value) || 0;
                const g = parseInt(this.gInput.value) || 0;
                const b = parseInt(this.bInput.value) || 0;
                this.setColorFromRgb(r, g, b);
            });
        });
        
        // Window resize
        window.addEventListener('resize', () => {
            this.setupCanvases();
            this.updateHandlePositions();
        });
    }
    
    startDrag(e, isColorSquare) {
        if (isColorSquare) {
            this.isDragging = true;
        } else {
            this.isHueDragging = true;
        }
        this.onDrag(e, isColorSquare);
    }
    
    onDrag(e, isColorSquare) {
        if (isColorSquare && this.isDragging) {
            const rect = this.colorCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const size = this.colorCanvas.width;
            
            this.saturation = Math.max(0, Math.min(100, (x / size) * 100));
            this.brightness = Math.max(0, Math.min(100, 100 - (y / size) * 100));
            this.updateColor();
        } else if (!isColorSquare && this.isHueDragging) {
            const rect = this.hueCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const width = this.hueCanvas.width;
            
            this.hue = Math.max(0, Math.min(360, (x / width) * 360));
            this.drawColorSquare();
            this.updateColor();
        }
    }
    
    stopDrag() {
        this.isDragging = false;
        this.isHueDragging = false;
    }
    
    setColorFromHex(hex) {
        const rgb = ColorConverter.hexToRgb(hex);
        if (!rgb) return;
        this.setColorFromRgb(rgb.r, rgb.g, rgb.b);
    }
    
    setColorFromRgb(r, g, b) {
        const hsl = ColorConverter.rgbToHsl(r, g, b);
        this.hue = hsl.h;
        this.saturation = hsl.s;
        this.brightness = hsl.l;
        
        this.drawColorSquare();
        this.updateColor();
    }
    
    updateHandlePositions() {
        const size = this.colorCanvas.width;
        const x = (this.saturation / 100) * size;
        const y = (1 - this.brightness / 100) * size;
        this.colorHandle.style.left = x + 'px';
        this.colorHandle.style.top = y + 'px';
        
        const hueX = (this.hue / 360) * this.hueCanvas.width;
        this.hueHandle.style.left = hueX + 'px';
    }
    
    updateColor() {
        const rgb = ColorConverter.hslToRgb(this.hue, this.saturation, this.brightness);
        const hex = ColorConverter.rgbToHex(rgb.r, rgb.g, rgb.b);
        
        // Update hidden input (this is critical!)
        this.colorInput.value = hex.toUpperCase();
        
        // Update displays
        this.hexInput.value = hex.toUpperCase();
        this.colorPreview.style.backgroundColor = hex;
        this.rInput.value = rgb.r;
        this.gInput.value = rgb.g;
        this.bInput.value = rgb.b;
        
        // Update handle positions
        this.updateHandlePositions();
    }
}

document.addEventListener('DOMContentLoaded', function() {
    const fileInput = document.getElementById('image');
    const uploadArea = document.getElementById('uploadArea');
    const uploadContent = document.getElementById('uploadContent');
    
    fileInput.addEventListener('change', function(e) {
        if (e.target.files.length > 0) {
            uploadContent.querySelector('p').textContent = 'Selected: ' + e.target.files[0].name;
        }
    });
    
    uploadArea.addEventListener('dragover', function(e) {
        e.preventDefault();
        uploadArea.style.borderColor = 'var(--primary-color)';
    });
    
    uploadArea.addEventListener('drop', function(e) {
        e.preventDefault();
        uploadArea.style.borderColor = 'var(--border-color)';
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            fileInput.files = files;
            uploadContent.querySelector('p').textContent = 'Selected: ' + files[0].name;
        }
    });
    
    // Initialize color picker
    if (document.getElementById('watermarkColorCanvas')) {
        new WatermarkColorPicker();
    }
});
</script>
{% endblock %}
{% endblock %}

