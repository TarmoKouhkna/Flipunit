{% extends 'base.html' %}

{% block title %}Audio Converter - Convert MP3, WAV, FLAC, AAC Online - {{ SITE_NAME }}{% endblock %}
{% block meta_description %}Free online audio converter - Convert between MP3, WAV, OGG, FLAC, AAC, AIFF, and M4A formats. Fast, simple, no registration required.{% endblock %}
{% block og_title %}Audio Converter - {{ SITE_NAME }}{% endblock %}
{% block og_description %}Free online audio converter - Convert between different audio formats.{% endblock %}

{% block content %}
<div class="card">
    <h1 class="card-title">Audio Converter - Convert Audio Files Online</h1>
    <p>Convert between different audio formats</p>
    
    {% if error %}
    <div class="alert alert-error">{{ error }}</div>
    {% endif %}
    
    <div class="privacy-notice">
        <p>
            <span>üîí</span>
            <span><strong>Privacy Notice:</strong> Your files are processed securely and are <strong>not stored</strong> on our servers. Files are temporarily saved during conversion and deleted immediately after processing.</span>
        </p>
    </div>
    
    <form method="post" enctype="multipart/form-data" class="converter-tool">
        {% csrf_token %}
        <div class="form-group">
            <label class="form-label" for="audio_file">Select Audio File</label>
            <div class="file-upload-area">
                <input type="file" name="audio_file" id="audio_file" accept="audio/*" multiple required>
                <div style="text-align: center; padding: 2rem;">
                    <p style="font-size: 1.1rem; margin-bottom: 1rem;">Click to select or drag and drop</p>
                    <p style="color: var(--text-secondary); font-size: 0.9rem;">Supports: MP3, WAV, OGG, FLAC, AAC, M4A, AIFF</p>
                    <p style="color: var(--primary-color); font-size: 0.9rem; margin-top: 0.5rem; font-weight: 600;">üí° Batch Mode: Select up to 15 files for batch conversion (downloads as ZIP)</p>
                </div>
            </div>
        </div>
        
        <div class="form-group" style="margin-top: 1.5rem;">
            <label class="form-label" for="output_format">Output Format</label>
            <select class="form-select" id="output_format" name="output_format" required>
                <option value="mp3">MP3</option>
                <option value="wav">WAV</option>
                <option value="ogg">OGG</option>
                <option value="flac">FLAC</option>
                <option value="aac">AAC</option>
                <option value="m4a">M4A</option>
                <option value="aiff">AIFF</option>
            </select>
        </div>
        
        <button type="submit" class="btn btn-primary btn-block" id="convertBtn">Convert Audio</button>
    </form>
    
    <!-- Job Status Area (for async processing) -->
    <div id="jobStatusArea" style="display: none; margin-top: 2rem; padding: 1.5rem; background: var(--surface); border-radius: 6px;">
        <div id="jobStatusMessage" style="text-align: center; font-size: 1.1rem; margin-bottom: 1rem;">
            <div class="spinner"></div> Processing...
        </div>
        <div id="jobIdDisplay" style="text-align: center; color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 1rem;"></div>
        <div id="jobError" style="display: none; color: var(--error-color); text-align: center; margin-top: 1rem;"></div>
    </div>
    
    <!-- Results Area (for completed jobs) -->
    <div id="resultsArea" style="display: none; margin-top: 2rem; padding: 1.5rem; background: var(--surface); border-radius: 6px;">
        <div style="text-align: center;">
            <h3 style="margin-bottom: 0.5rem; color: var(--success-color, #4caf50);">‚úÖ Conversion Completed!</h3>
            <p style="color: var(--text-secondary); margin-bottom: 1.5rem; font-size: 0.95rem;">Your audio file has been converted successfully. Click below to download.</p>
            <a id="downloadBtn" href="#" class="btn btn-primary" style="min-width: 220px; font-size: 1rem;">‚¨áÔ∏è Download Converted File</a>
        </div>
    </div>
    
    <div style="margin-top: 2rem; padding: 1rem; background: var(--surface); border-radius: 6px;">
        <h3>How to use:</h3>
        <ol class="list-indent" style="margin-top: 0.5rem;">
            <li>Upload an audio file (MP3, WAV, OGG, FLAC, AAC, M4A, or AIFF)</li>
            <li>Select the desired output format</li>
            <li>Click "Convert Audio"</li>
            <li>Wait for conversion to complete (you'll see progress updates)</li>
            <li>Click "Download Converted File" when ready</li>
        </ol>
        <p style="margin-top: 1rem; color: var(--text-secondary);">
            <strong>Note:</strong> Lossy formats (MP3, OGG, AAC) are converted at 192 kbps quality. Lossless formats (WAV, FLAC) preserve original quality.
        </p>
    </div>
</div>

<a href="{% url 'media_converter:index' %}" class="btn btn-secondary">‚Üê Back to Media Converters</a>
{% endblock %}

{% block extra_js %}
<!-- AUDIO CONVERTER SCRIPT v2.0.2025-01-19 - If you see this comment, the template is loading -->
<script>
// === VERSION CHECK - FORCE CACHE BUST ===
const AUDIO_CONVERTER_VERSION = 'v2.1.2025-01-19-FIXED';
console.log('üîµüîµüîµ AUDIO CONVERTER SCRIPT LOADED - VERSION:', AUDIO_CONVERTER_VERSION);
console.log('üîµ Timestamp:', new Date().toISOString());
console.log('üîµ URL:', window.location.href);
console.log('üîµüîµüîµ CODE FIX: Direct submit handler call (not event dispatch)');
console.log('üîµüîµüîµ CODE FIX: File input handlers restored');

// Version check complete

// === GLOBAL FETCH PROTECTION (runs immediately, before anything else) ===
(function() {
    'use strict';
    if (window._audioConverterFetchProtected) {
        console.error('‚ùå‚ùå‚ùå CRITICAL: Fetch protection already installed - script loaded TWICE!');
        console.trace('Stack trace:');
        return; // Already protected
    }
    window._audioConverterFetchProtected = true;
    console.log('‚úÖ Fetch protection installing...');
    
    const originalFetch = window.fetch;
    let isProcessing = false; // Synchronous lock - no Map needed
    
    window.fetch = function(url, options = {}) {
        const urlString = typeof url === 'string' ? url : (url?.toString() || '');
        const isPost = (options.method || 'GET').toUpperCase() === 'POST';
        // Only block POST requests to the audio converter endpoint (strict check)
        // Parse URL to check pathname only (not query string) to avoid false positives
        let urlPath = urlString;
        try {
            const urlObj = new URL(urlString);
            urlPath = urlObj.pathname; // Only check the path, not query parameters
        } catch (e) {
            // If URL parsing fails, use the original string
            urlPath = urlString;
        }
        const isAudioConverter = urlPath.includes('/media-converter/audio-converter') && 
                                  !urlString.includes('google-analytics') &&
                                  !urlString.includes('gtm');
        
        if (isPost && isAudioConverter) {
            // SYNCHRONOUS CHECK - happens before any async code
            if (isProcessing) {
                console.error('üö´üö´üö´ BLOCKED DUPLICATE FETCH (synchronous lock):', urlString);
                console.trace('Stack trace for blocked request:');
                return Promise.reject(new Error('Duplicate request blocked by synchronous lock'));
            }
            
            // Set lock IMMEDIATELY (synchronously)
            isProcessing = true;
            console.log('‚úÖ ALLOWED FETCH (lock set):', urlString);
            
            // Clean up after request completes (small delay to catch rapid duplicates)
            const fetchPromise = originalFetch.apply(this, arguments);
            fetchPromise.finally(() => {
                // Release lock immediately, but with a tiny delay (100ms) to catch rapid-fire duplicates
                setTimeout(() => {
                    isProcessing = false;
                    console.log('üîì Lock released');
                }, 100);
            });
            
            return fetchPromise;
        }
        
        return originalFetch.apply(this, arguments);
    };
    
    console.log('üõ°Ô∏è Global fetch protection installed (synchronous lock mode)');
    console.log('Current fetch function:', window.fetch);
})();

// === SINGLE EXECUTION GUARD ===
if (window.audioConverterInitialized) {
    console.log('‚ö†Ô∏è Audio converter script already initialized - skipping');
} else {
    window.audioConverterInitialized = true;
    console.log('‚úÖ Audio converter script initializing...');

    document.addEventListener('DOMContentLoaded', () => {
        console.log('üîµ DOMContentLoaded fired');
        const form = document.querySelector('.converter-tool');
        if (!form) {
            console.error('‚ùå Form not found!');
            return;
        }
        console.log('‚úÖ Form found:', form);

        // GLOBAL STATE - shared across all instances
        if (!window._audioConverterState) {
            window._audioConverterState = {
                isProcessing: false,
                downloadTriggered: false,
                abortController: null,
                submitCount: 0,
                isAsyncJob: false  // Flag to track if current job is async
            };
        }
        const state = window._audioConverterState;

        const submitHandler = async (e) => {
            state.submitCount++;
            console.log('üìù Submit handler called, count:', state.submitCount);
            console.log('üìù Event type:', e.type);
            console.log('üìù Event target:', e.target);
            
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();

            // === INSTANT DOUBLE-CLICK PROTECTION ===
            if (state.isProcessing) {
                console.error('üö´üö´üö´ Submit BLOCKED: already processing (count:', state.submitCount, ')');
                return false;
            }

            const fileInput = form.querySelector('#audio_file');
            if (!fileInput?.files?.length) {
                alert('Please select an audio file');
                return false;
            }

            // === LOCK IMMEDIATELY ===
            state.isProcessing = true;
            state.downloadTriggered = false;
            console.log('üîí Lock set, submit count:', state.submitCount);
            
            // Find button by class or any button in the form (since we changed type to "button")
            const submitBtn = form.querySelector('button.btn-primary, button[type="button"], button[type="submit"]');
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.textContent = 'Uploading...';
            } else {
                console.error('‚ùå Submit button not found!');
            }
            form.style.pointerEvents = 'none';

            // Abort any previous fetch to kill duplicates
            if (state.abortController) {
                state.abortController.abort();
                console.log('Previous fetch aborted');
            }
            state.abortController = new AbortController(); // Fresh controller

            // Cleanup any old blob URLs
            document.querySelectorAll('a[data-temp-download]').forEach(a => {
                if (a.href.startsWith('blob:')) {
                    URL.revokeObjectURL(a.href);
                }
                a.remove();
            });
        
        const formData = new FormData(form);
        
            try {
                console.log('üì§ About to call fetch...');
                const fetchUrl = form.action || window.location.href;
                console.log('üì§ Fetch URL:', fetchUrl);
                console.log('üì§ FormData keys:', Array.from(formData.keys()));
                console.log('üì§ File in FormData:', formData.get('audio_file')?.name);
                console.log('üì§ Current fetch function:', window.fetch);
                console.log('üì§ Is protected?', window._audioConverterFetchProtected);
                
                const response = await fetch(fetchUrl, {
                    method: 'POST',
                    body: formData,
                    credentials: 'same-origin',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                        'Accept': 'application/json'
                    },
                    signal: state.abortController.signal // Allows abort
                });
                
                console.log('üì• Fetch response received:', response.status);
                console.log('üì• Response headers:', Object.fromEntries(response.headers.entries()));

                let blob, filename, contentType = 'audio/mpeg';

                const contentTypeHeader = response.headers.get('content-type');
                
                if (!response.ok) {
                    // Try to get error message from response
                    let errorMessage = 'Conversion failed';
                    try {
                        if (contentTypeHeader?.includes('application/json')) {
                            const errorData = await response.json();
                            errorMessage = errorData.error || errorData.message || errorMessage;
                        } else {
                            const text = await response.text();
                            // Try to extract error from HTML if it's an error page
                            const errorMatch = text.match(/<div[^>]*class="[^"]*alert[^"]*error[^"]*"[^>]*>([^<]+)<\/div>/i);
                            if (errorMatch) {
                                errorMessage = errorMatch[1].trim();
                            } else if (text.length < 500) {
                                errorMessage = text.substring(0, 200);
                            }
                        }
                    } catch (e) {
                        console.error('Error parsing error response:', e);
                    }
                    throw new Error(errorMessage || `Server returned status ${response.status}`);
                }
                
                // Check if this is a ZIP file (batch conversion)
                if (contentTypeHeader?.includes('application/zip')) {
                    // ZIP format - batch conversion
                    blob = await response.blob();
                    filename = 'converted_audio.zip';
                    contentType = 'application/zip';
                    blob = new Blob([blob], { type: contentType });
                } else if (contentTypeHeader?.includes('application/json')) {
                    // JSON format - could be async job or legacy base64 response
                    const data = await response.json();
                    
                    // Check if response contains an error
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    
                    // Check if this is an async job response (has job_id)
                    if (data.job_id) {
                        // Async job - start polling
                        console.log('üîÑ Async job created:', data.job_id);
                        
                        // Mark as async job to prevent finally block from resetting button
                        state.isAsyncJob = true;
                        
                        // Update button to show processing state
                        const submitBtn = form.querySelector('button.btn-primary, button[type="button"], button[type="submit"]');
                        if (submitBtn) {
                            submitBtn.disabled = true;
                            submitBtn.textContent = 'Processing...';
                        }
                        
                        // Show job status area
                        document.getElementById('jobStatusArea').style.display = 'block';
                        document.getElementById('resultsArea').style.display = 'none';
                        document.getElementById('jobStatusMessage').innerHTML = '<div class="spinner"></div> Job created. Processing in background...';
                        document.getElementById('jobIdDisplay').textContent = `Job ID: ${data.job_id}`;
                        document.getElementById('jobError').style.display = 'none';
                        
                        // Start polling
                        startJobPolling(data.job_id);
                        return; // Exit early - polling will handle completion
                    }
                    
                    // Legacy format - base64 encoded file
                    if (data.file) {
                        const binary = atob(data.file);
                        const bytes = new Uint8Array(binary.length);
                        for (let i = 0; i < binary.length; i++) {
                            bytes[i] = binary.charCodeAt(i);
                        }
                        blob = new Blob([bytes], { type: data.content_type || 'audio/mpeg' });
                        filename = data.filename;
                        contentType = data.content_type || 'audio/mpeg';
                    } else {
                        throw new Error('Invalid response format from server');
                    }
                } else {
                    // Legacy format - direct audio file
                    blob = await response.blob();
                    filename = response.headers.get('x-filename') || 'converted.audio';
                    contentType = response.headers.get('x-content-type') || contentTypeHeader || 'audio/mpeg';
                    blob = new Blob([blob], { type: contentType });
                }

                // === FINAL DUPLICATE DOWNLOAD GUARD ===
                if (state.downloadTriggered) {
                    console.error('üö´üö´üö´ Download already triggered, skipping (submit count:', state.submitCount, ')');
                    return;
                }
                state.downloadTriggered = true;
                console.log('‚úÖ Download triggered (submit count:', state.submitCount, ')');

                // Add timestamp to filename to prevent browser de-duping (only for single files, not ZIP)
                let uniqueFilename = filename;
                if (!filename.endsWith('.zip')) {
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
                    const fileExt = filename.match(/\.[^/.]+$/) || '.mp3';
                    const baseName = filename.replace(/\.[^/.]+$/, '');
                    uniqueFilename = `${baseName}-${timestamp}${fileExt}`;
                }

                const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
                a.download = uniqueFilename; // Use unique name
                a.dataset.tempDownload = 'true';
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            
                // Cleanup
                setTimeout(() => {
                    if (document.body.contains(a)) {
                document.body.removeChild(a);
                    }
                    URL.revokeObjectURL(url);
            }, 100);
            
            } catch (err) {
                // Ignore abort errors (expected for duplicates)
                if (err.name === 'AbortError') {
                    console.log('Fetch aborted (duplicate prevented)');
                    return;
                }
                // Silently ignore duplicate request errors - they're handled by the lock mechanism
                if (err.message && err.message.includes('Duplicate request blocked')) {
                    console.log('Duplicate request blocked (already processing)');
                    return;
                }
                console.error('Conversion error:', err);
                const errorMessage = err.message || 'Conversion failed. Please try again.';
                alert(errorMessage);
                // Don't reload if it's a specific error message - let user try again
                if (errorMessage.includes('Please try again') || errorMessage.length < 20) {
                    window.location.reload();
                }
            } finally {
                // === ALWAYS RESET (unless async job) ===
                console.log('üîì Releasing lock (submit count:', state.submitCount, ')');
                
                // Don't reset button state for async jobs - let download handler do it
                if (!state.isAsyncJob) {
                    state.isProcessing = false;
                    state.downloadTriggered = false; // Reset download flag
                    state.abortController = null; // Clear controller
                    
                    // Find button again (in case form was re-rendered)
                    const submitBtn = form.querySelector('button.btn-primary, button[type="button"], button[type="submit"]');
                    if (submitBtn) {
                        submitBtn.disabled = false;
                        submitBtn.textContent = 'Convert Audio';
                    }
                    form.style.pointerEvents = 'auto';
                } else {
                    // For async jobs, only clear abort controller and reset download flag
                    state.downloadTriggered = false;
                    state.abortController = null;
                    form.style.pointerEvents = 'auto';
                    // Keep button as "Processing..." and isProcessing = true
                }
            }
        };

        // DON'T clone the form - it breaks file input handlers
        // Instead, just remove existing submit listeners by replacing the form's submit handler
        const submitBtn = form.querySelector('button.btn-primary');
        
        // Change button type to prevent any native form submission
        if (submitBtn) {
            submitBtn.type = 'button'; // Change from 'submit' to 'button'
            
            // Add click handler that manually triggers our submit handler
            submitBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopImmediatePropagation();
                e.stopPropagation();
                
                if (window._audioConverterState?.isProcessing) {
                    console.error('üö´ Button click blocked: already processing');
                    return false;
                }
                
                console.log('üñ±Ô∏èüñ±Ô∏èüñ±Ô∏è BUTTON CLICKED - CALLING SUBMIT HANDLER DIRECTLY (v2.1 FIX)');
                // Call submit handler directly instead of dispatching event
                const submitEvent = { 
                    type: 'submit',
                    target: form,
                    preventDefault: () => {},
                    stopPropagation: () => {},
                    stopImmediatePropagation: () => {}
                };
                console.log('üñ±Ô∏è About to call submitHandler function...');
                submitHandler(submitEvent);
                console.log('üñ±Ô∏è submitHandler call completed');
            }, { capture: true, once: false });
        }

        // Completely prevent any native form submission
        form.addEventListener('submit', function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
            e.stopPropagation();
            return false;
        }, { capture: true });
        
        // Also set onsubmit to prevent any fallback
        form.onsubmit = function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
            e.stopPropagation();
            return false;
        };
        
        // Attach our handler LAST, with highest priority
        form.addEventListener('submit', submitHandler, { capture: false, once: false });
        
        // Ensure file input is working - main.js should handle it, but verify
        const fileInput = form.querySelector('#audio_file');
        const uploadArea = form.querySelector('.file-upload-area');
        console.log('üìÅ File input found:', fileInput);
        console.log('üìÅ Upload area found:', uploadArea);
        
        if (fileInput && uploadArea) {
            // Make sure file input is accessible
            fileInput.style.display = 'block';
            fileInput.style.opacity = '0';
            fileInput.style.position = 'absolute';
            fileInput.style.width = '100%';
            fileInput.style.height = '100%';
            fileInput.style.cursor = 'pointer';
            
            // Ensure upload area is clickable
            uploadArea.style.cursor = 'pointer';
            uploadArea.style.position = 'relative';
            
            // Note: Click handler is already attached by main.js globally
            // No need to add duplicate handler here
            
            // Update display when file is selected
            fileInput.addEventListener('change', (e) => {
                console.log('üìÅ Files selected:', e.target.files.length);
                if (e.target.files.length > 15) {
                    alert('Maximum 15 files allowed for batch conversion. Please select fewer files.');
                    e.target.value = '';
                    return;
                }
                const fileName = e.target.files[0]?.name;
                const p = uploadArea.querySelector('p');
                if (p) {
                    if (e.target.files.length === 1) {
                        p.textContent = 'Selected: ' + fileName;
                    } else {
                        p.textContent = `${e.target.files.length} files selected (will be converted and downloaded as ZIP)`;
                    }
                }
            });
            
            console.log('‚úÖ File input handlers attached');
        } else {
            console.error('‚ùå File input or upload area not found!');
        }
    });
    
    // Async job polling functions
    let pollInterval = null;
    
    function startJobPolling(jobId) {
        clearInterval(pollInterval); // Clear any existing interval
        
        console.log('üîÑ Starting job polling for jobId:', jobId);
        pollInterval = setInterval(() => {
            fetch(`/media-converter/job/status/${jobId}/`)
                .then(response => response.json())
                .then(data => {
                    updateJobStatus(data);

                    if (data.status === 'completed' || data.status === 'failed') {
                        clearInterval(pollInterval);
                        console.log('üõë Polling stopped, job status:', data.status);
                        
                        if (data.status === 'completed') {
                            console.log('‚úÖ Job completed, calling showConversionResult');
                            showConversionResult(data, jobId);
                            // Keep button as "Processing..." until download is clicked
                            // Don't reset button state here - wait for download click
                        } else {
                            console.log('‚ùå Job failed');
                            showJobError(data.error_message || 'Conversion failed. Please try again.');
                            // Reset form state
                            const submitBtn = form.querySelector('button.btn-primary, button[type="button"], button[type="submit"]');
                            if (submitBtn) {
                                submitBtn.disabled = false;
                                submitBtn.textContent = 'Convert Audio';
                            }
                            state.isProcessing = false;
                        }
                    }
                })
                .catch(error => {
                    console.error('Polling error:', error);
                    // Continue polling on error (might be temporary network issue)
                });
        }, 2000); // Poll every 2 seconds
    }
    
    function updateJobStatus(data) {
        const jobStatusMessage = document.getElementById('jobStatusMessage');
        const jobIdDisplay = document.getElementById('jobIdDisplay');
        const jobError = document.getElementById('jobError');
        
        if (!jobStatusMessage || !jobIdDisplay || !jobError) return; // Safety check
        
        jobIdDisplay.textContent = `Job ID: ${data.job_id}`;
        jobError.style.display = 'none';
        
        let statusText = '';
        let spinner = '<div class="spinner"></div>';
        
        switch (data.status) {
            case 'pending':
                statusText = `${spinner} Job created. Waiting to process...`;
                break;
            case 'processing':
                statusText = `${spinner} Converting audio file...`;
                break;
            case 'completed':
                statusText = '‚úÖ Conversion completed!';
                break;
            case 'failed':
                statusText = '‚ùå Conversion failed.';
                jobError.textContent = data.error_message || 'An unknown error occurred.';
                jobError.style.display = 'block';
                break;
            default:
                statusText = `${spinner} Unknown status: ${data.status}`;
        }
        jobStatusMessage.innerHTML = statusText;
    }
    
    function showConversionResult(data, jobId) {
        console.log('üéØ showConversionResult called with jobId:', jobId);
        const resultsArea = document.getElementById('resultsArea');
        const downloadBtn = document.getElementById('downloadBtn');
        
        if (!resultsArea || !downloadBtn) {
            console.error('‚ùå Results area or download button not found!', { resultsArea, downloadBtn });
            return; // Safety check
        }
        
        console.log('‚úÖ Found results area and download button');
        
        // Update download link
        downloadBtn.href = `/media-converter/job/download/${jobId}/`;
        console.log('‚úÖ Download link set to:', downloadBtn.href);
        
        // Instead of cloning, just remove old listeners and add new one
        // Use onclick directly for more reliable behavior
        downloadBtn.onclick = function resetButtonAfterDownload(e) {
            console.log('üîµüîµüîµ Download button clicked, resetting form button');
            
            // Reset the form button immediately (don't wait for download)
            // Try multiple selectors to find the submit button
            let submitBtn = document.querySelector('.converter-tool button.btn-primary');
            if (!submitBtn) {
                submitBtn = document.querySelector('.converter-tool button[type="submit"]');
            }
            if (!submitBtn) {
                submitBtn = document.querySelector('.converter-tool button[type="button"]');
            }
            if (!submitBtn) {
                // Last resort: find any button in the form
                const form = document.querySelector('.converter-tool');
                if (form) {
                    submitBtn = form.querySelector('button');
                }
            }
            
            if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Convert Audio';
                console.log('‚úÖ‚úÖ‚úÖ Form button reset to "Convert Audio"');
            } else {
                console.error('‚ùå‚ùå‚ùå Could not find submit button to reset');
            }
            
            // Reset state flags using global state
            const state = window._audioConverterState;
            if (state) {
                state.isProcessing = false;
                state.isAsyncJob = false;
                console.log('‚úÖ‚úÖ‚úÖ State flags reset');
            } else {
                console.warn('‚ö†Ô∏è Global state not found');
            }
            
            // Allow default download behavior (don't preventDefault)
            // Return true to allow navigation
            return true;
        };
        
        console.log('‚úÖ Download button onclick handler attached');
        
        // Show results area
        resultsArea.style.display = 'block';
        document.getElementById('jobStatusArea').style.display = 'none';
        console.log('‚úÖ Results area displayed');
    }
    
    function showJobError(message) {
        const jobStatusMessage = document.getElementById('jobStatusMessage');
        const jobError = document.getElementById('jobError');
        if (!jobStatusMessage || !jobError) return; // Safety check
        jobStatusMessage.innerHTML = '‚ùå Error occurred.';
        jobError.textContent = message;
        jobError.style.display = 'block';
    }
}
</script>
{% endblock extra_js %}