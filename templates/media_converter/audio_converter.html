{% extends 'base.html' %}

{% block title %}Audio Converter - {{ SITE_NAME }}{% endblock %}
{% block meta_description %}Free online audio converter - Convert between MP3, WAV, OGG, FLAC, and AAC formats. Fast, simple, no registration required.{% endblock %}
{% block og_title %}Audio Converter - {{ SITE_NAME }}{% endblock %}
{% block og_description %}Free online audio converter - Convert between different audio formats.{% endblock %}

{% block content %}
<div class="card">
    <h1 class="card-title">Audio Converter</h1>
    <p>Convert between different audio formats</p>
    
    {% if error %}
    <div class="alert alert-error">{{ error }}</div>
    {% endif %}
    
    <form method="post" enctype="multipart/form-data" class="converter-tool">
        {% csrf_token %}
        <div class="form-group">
            <label class="form-label" for="audio_file">Select Audio File</label>
            <div class="file-upload-area">
                <input type="file" name="audio_file" id="audio_file" accept="audio/*" required>
                <div style="text-align: center; padding: 2rem;">
                    <p style="font-size: 1.1rem; margin-bottom: 1rem;">Click to select or drag and drop</p>
                    <p style="color: var(--text-secondary); font-size: 0.9rem;">Supports: MP3, WAV, OGG, FLAC, AAC, M4A</p>
                </div>
            </div>
        </div>
        
        <div class="form-group" style="margin-top: 1.5rem;">
            <label class="form-label" for="output_format">Output Format</label>
            <select class="form-select" id="output_format" name="output_format" required>
                <option value="mp3">MP3</option>
                <option value="wav">WAV</option>
                <option value="ogg">OGG</option>
                <option value="flac">FLAC</option>
                <option value="aac">AAC</option>
            </select>
        </div>
        
        <button type="submit" class="btn btn-primary btn-block">Convert & Download</button>
    </form>
    
    <div style="margin-top: 2rem; padding: 1rem; background: var(--surface); border-radius: 6px;">
        <h3>How to use:</h3>
        <ol style="margin-left: 1.5rem; margin-top: 0.5rem;">
            <li>Upload an audio file (MP3, WAV, OGG, FLAC, or AAC)</li>
            <li>Select the desired output format</li>
            <li>Click "Convert & Download"</li>
            <li>Download the converted audio file</li>
        </ol>
        <p style="margin-top: 1rem; color: var(--text-secondary);">
            <strong>Note:</strong> Lossy formats (MP3, OGG, AAC) are converted at 192 kbps quality. Lossless formats (WAV, FLAC) preserve original quality.
        </p>
    </div>
</div>

<a href="{% url 'media_converter:index' %}" class="btn btn-secondary">‚Üê Back to Media Converters</a>
{% endblock %}

{% block extra_js %}
<!-- AUDIO CONVERTER SCRIPT v2.0.2025-01-19 - If you see this comment, the template is loading -->
<script>
// === VERSION CHECK - FORCE CACHE BUST ===
const AUDIO_CONVERTER_VERSION = 'v2.1.2025-01-19-FIXED';
console.log('üîµüîµüîµ AUDIO CONVERTER SCRIPT LOADED - VERSION:', AUDIO_CONVERTER_VERSION);
console.log('üîµ Timestamp:', new Date().toISOString());
console.log('üîµ URL:', window.location.href);
console.log('üîµüîµüîµ CODE FIX: Direct submit handler call (not event dispatch)');
console.log('üîµüîµüîµ CODE FIX: File input handlers restored');

// Force immediate execution - no waiting
(function() {
    alert('‚úÖ NEW CODE v2.1 LOADED! Direct submit handler fix included!');
    console.error('üî¥üî¥üî¥ ALERT SHOULD HAVE APPEARED - IF NOT, SCRIPT NOT LOADING');
})();

// === GLOBAL FETCH PROTECTION (runs immediately, before anything else) ===
(function() {
    'use strict';
    if (window._audioConverterFetchProtected) {
        console.error('‚ùå‚ùå‚ùå CRITICAL: Fetch protection already installed - script loaded TWICE!');
        console.trace('Stack trace:');
        return; // Already protected
    }
    window._audioConverterFetchProtected = true;
    console.log('‚úÖ Fetch protection installing...');
    
    const originalFetch = window.fetch;
    let isProcessing = false; // Synchronous lock - no Map needed
    
    window.fetch = function(url, options = {}) {
        const urlString = typeof url === 'string' ? url : (url?.toString() || '');
        const isPost = (options.method || 'GET').toUpperCase() === 'POST';
        const isAudioConverter = urlString.includes('audio-converter');
        
        if (isPost && isAudioConverter) {
            // SYNCHRONOUS CHECK - happens before any async code
            if (isProcessing) {
                console.error('üö´üö´üö´ BLOCKED DUPLICATE FETCH (synchronous lock):', urlString);
                console.trace('Stack trace for blocked request:');
                return Promise.reject(new Error('Duplicate request blocked by synchronous lock'));
            }
            
            // Set lock IMMEDIATELY (synchronously)
            isProcessing = true;
            console.log('‚úÖ ALLOWED FETCH (lock set):', urlString);
            
            // Clean up after request completes (with delay to catch rapid duplicates)
            const fetchPromise = originalFetch.apply(this, arguments);
            fetchPromise.finally(() => {
                // Wait 2 seconds before releasing lock to catch any rapid duplicates
                setTimeout(() => {
                    isProcessing = false;
                    console.log('üîì Lock released');
                }, 2000);
            });
            
            return fetchPromise;
        }
        
        return originalFetch.apply(this, arguments);
    };
    
    console.log('üõ°Ô∏è Global fetch protection installed (synchronous lock mode)');
    console.log('Current fetch function:', window.fetch);
})();

// === SINGLE EXECUTION GUARD ===
if (window.audioConverterInitialized) {
    console.log('‚ö†Ô∏è Audio converter script already initialized - skipping');
} else {
    window.audioConverterInitialized = true;
    console.log('‚úÖ Audio converter script initializing...');

    document.addEventListener('DOMContentLoaded', () => {
        console.log('üîµ DOMContentLoaded fired');
        const form = document.querySelector('.converter-tool');
        if (!form) {
            console.error('‚ùå Form not found!');
            return;
        }
        console.log('‚úÖ Form found:', form);

        // GLOBAL STATE - shared across all instances
        if (!window._audioConverterState) {
            window._audioConverterState = {
                isProcessing: false,
                downloadTriggered: false,
                abortController: null,
                submitCount: 0
            };
        }
        const state = window._audioConverterState;

        const submitHandler = async (e) => {
            state.submitCount++;
            console.log('üìù Submit handler called, count:', state.submitCount);
            console.log('üìù Event type:', e.type);
            console.log('üìù Event target:', e.target);
            
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();

            // === INSTANT DOUBLE-CLICK PROTECTION ===
            if (state.isProcessing) {
                console.error('üö´üö´üö´ Submit BLOCKED: already processing (count:', state.submitCount, ')');
                return false;
            }

            const fileInput = form.querySelector('#audio_file');
            if (!fileInput?.files?.length) {
                alert('Please select an audio file');
                return false;
            }

            // === LOCK IMMEDIATELY ===
            state.isProcessing = true;
            state.downloadTriggered = false;
            console.log('üîí Lock set, submit count:', state.submitCount);
            
            const submitBtn = form.querySelector('button[type="submit"]');
        submitBtn.disabled = true;
        submitBtn.textContent = 'Processing...';
            form.style.pointerEvents = 'none';

            // Abort any previous fetch to kill duplicates
            if (state.abortController) {
                state.abortController.abort();
                console.log('Previous fetch aborted');
            }
            state.abortController = new AbortController(); // Fresh controller

            // Cleanup any old blob URLs
            document.querySelectorAll('a[data-temp-download]').forEach(a => {
                if (a.href.startsWith('blob:')) {
                    URL.revokeObjectURL(a.href);
                }
                a.remove();
            });
        
        const formData = new FormData(form);
        
            try {
                console.log('üì§ About to call fetch...');
                const fetchUrl = form.action || window.location.href;
                console.log('üì§ Fetch URL:', fetchUrl);
                console.log('üì§ FormData keys:', Array.from(formData.keys()));
                console.log('üì§ File in FormData:', formData.get('audio_file')?.name);
                console.log('üì§ Current fetch function:', window.fetch);
                console.log('üì§ Is protected?', window._audioConverterFetchProtected);
                
                const response = await fetch(fetchUrl, {
                    method: 'POST',
                    body: formData,
                    credentials: 'same-origin',
                    signal: state.abortController.signal // Allows abort
                });
                
                console.log('üì• Fetch response received:', response.status);
                console.log('üì• Response headers:', Object.fromEntries(response.headers.entries()));

                if (!response.ok) {
                    throw new Error('Conversion failed');
                }

                let blob, filename, contentType = 'audio/mpeg';

                const contentTypeHeader = response.headers.get('content-type');
                if (contentTypeHeader?.includes('application/json')) {
                    // JSON format - extract file data
                    const data = await response.json();
                    const binary = atob(data.file);
                    const bytes = new Uint8Array(binary.length);
                    for (let i = 0; i < binary.length; i++) {
                        bytes[i] = binary.charCodeAt(i);
                    }
                    blob = new Blob([bytes], { type: data.content_type || 'audio/mpeg' });
                    filename = data.filename;
                    contentType = data.content_type || 'audio/mpeg';
            } else {
                    // Legacy format - direct audio file
                    blob = await response.blob();
                    filename = response.headers.get('x-filename') || 'converted.audio';
                    contentType = response.headers.get('x-content-type') || contentTypeHeader || 'audio/mpeg';
                    blob = new Blob([blob], { type: contentType });
                }

                // === FINAL DUPLICATE DOWNLOAD GUARD ===
                if (state.downloadTriggered) {
                    console.error('üö´üö´üö´ Download already triggered, skipping (submit count:', state.submitCount, ')');
                    return;
                }
                state.downloadTriggered = true;
                console.log('‚úÖ Download triggered (submit count:', state.submitCount, ')');

                // Add timestamp to filename to prevent browser de-duping
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
                const fileExt = filename.match(/\.[^/.]+$/) || '.mp3';
                const baseName = filename.replace(/\.[^/.]+$/, '');
                const uniqueFilename = `${baseName}-${timestamp}${fileExt}`;

                const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
                a.download = uniqueFilename; // Use unique name
                a.dataset.tempDownload = 'true';
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            
                // Cleanup
                setTimeout(() => {
                    if (document.body.contains(a)) {
                document.body.removeChild(a);
                    }
                    URL.revokeObjectURL(url);
            }, 100);
            
            } catch (err) {
                // Ignore abort errors (expected for duplicates)
                if (err.name === 'AbortError') {
                    console.log('Fetch aborted (duplicate prevented)');
                    return;
                }
                console.error('Conversion error:', err);
                alert('Conversion failed. Please try again.');
                window.location.reload();
            } finally {
                // === ALWAYS RESET ===
                console.log('üîì Releasing lock (submit count:', state.submitCount, ')');
                state.isProcessing = false;
                state.abortController = null; // Clear controller
            submitBtn.disabled = false;
            submitBtn.textContent = 'Convert & Download';
                form.style.pointerEvents = 'auto';
            }
        };

        // DON'T clone the form - it breaks file input handlers
        // Instead, just remove existing submit listeners by replacing the form's submit handler
        const submitBtn = form.querySelector('button[type="submit"]');
        
        // Change button type to prevent any native form submission
        if (submitBtn) {
            submitBtn.type = 'button'; // Change from 'submit' to 'button'
            
            // Add click handler that manually triggers our submit handler
            submitBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopImmediatePropagation();
                e.stopPropagation();
                
                if (window._audioConverterState?.isProcessing) {
                    console.error('üö´ Button click blocked: already processing');
                    return false;
                }
                
                console.log('üñ±Ô∏èüñ±Ô∏èüñ±Ô∏è BUTTON CLICKED - CALLING SUBMIT HANDLER DIRECTLY (v2.1 FIX)');
                // Call submit handler directly instead of dispatching event
                const submitEvent = { 
                    type: 'submit',
                    target: form,
                    preventDefault: () => {},
                    stopPropagation: () => {},
                    stopImmediatePropagation: () => {}
                };
                console.log('üñ±Ô∏è About to call submitHandler function...');
                submitHandler(submitEvent);
                console.log('üñ±Ô∏è submitHandler call completed');
            }, { capture: true, once: false });
        }

        // Completely prevent any native form submission
        form.addEventListener('submit', function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
            e.stopPropagation();
            return false;
        }, { capture: true });
        
        // Also set onsubmit to prevent any fallback
        form.onsubmit = function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
            e.stopPropagation();
            return false;
        };
        
        // Attach our handler LAST, with highest priority
        form.addEventListener('submit', submitHandler, { capture: false, once: false });
        
        // Ensure file input is working - main.js should handle it, but verify
        const fileInput = form.querySelector('#audio_file');
        const uploadArea = form.querySelector('.file-upload-area');
        console.log('üìÅ File input found:', fileInput);
        console.log('üìÅ Upload area found:', uploadArea);
        
        if (fileInput && uploadArea) {
            // Make sure file input is accessible
            fileInput.style.display = 'block';
            fileInput.style.opacity = '0';
            fileInput.style.position = 'absolute';
            fileInput.style.width = '100%';
            fileInput.style.height = '100%';
            fileInput.style.cursor = 'pointer';
            
            // Ensure upload area is clickable
            uploadArea.style.cursor = 'pointer';
            uploadArea.style.position = 'relative';
            
            // Add a backup click handler in case main.js didn't attach one
            uploadArea.addEventListener('click', function(e) {
                console.log('üñ±Ô∏è Upload area clicked');
                if (e.target !== fileInput && !fileInput.contains(e.target)) {
                    console.log('üñ±Ô∏è Triggering file input click');
                    fileInput.click();
                }
            }, { capture: false });
            
            // Update display when file is selected
            fileInput.addEventListener('change', (e) => {
                console.log('üìÅ File selected:', e.target.files[0]?.name);
                const fileName = e.target.files[0]?.name;
                const p = uploadArea.querySelector('p');
                if (p && fileName) {
                    p.textContent = 'Selected: ' + fileName;
                }
            });
            
            console.log('‚úÖ File input handlers attached');
        } else {
            console.error('‚ùå File input or upload area not found!');
        }
    });
}
</script>
{% endblock extra_js %}
