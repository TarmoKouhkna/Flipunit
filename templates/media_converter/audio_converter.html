{% extends 'base.html' %}

{% block title %}Audio Converter - {{ SITE_NAME }}{% endblock %}
{% block meta_description %}Free online audio converter - Convert between MP3, WAV, OGG, FLAC, AAC, AIFF, and M4A formats. Fast, simple, no registration required.{% endblock %}
{% block og_title %}Audio Converter - {{ SITE_NAME }}{% endblock %}
{% block og_description %}Free online audio converter - Convert between different audio formats.{% endblock %}

{% block content %}
<div class="card">
    <h1 class="card-title">Audio Converter</h1>
    <p>Convert between different audio formats</p>
    
    {% if error %}
    <div class="alert alert-error">{{ error }}</div>
    {% endif %}
    
    <div style="margin-bottom: 1.5rem; padding: 1rem; background: #e0f2fe; border-left: 4px solid #0284c7; border-radius: 6px;">
        <p style="margin: 0; color: #0c4a6e; font-size: 0.9rem; display: flex; align-items: center; gap: 0.5rem;">
            <span style="font-size: 1.2rem;">üîí</span>
            <span><strong>Privacy Notice:</strong> Your files are processed securely and are <strong>not stored</strong> on our servers. Files are temporarily saved during conversion and deleted immediately after processing.</span>
        </p>
    </div>
    
    <form method="post" enctype="multipart/form-data" class="converter-tool">
        {% csrf_token %}
        <div class="form-group">
            <label class="form-label" for="audio_file">Select Audio File</label>
            <div class="file-upload-area">
                <input type="file" name="audio_file" id="audio_file" accept="audio/*" multiple required>
                <div style="text-align: center; padding: 2rem;">
                    <p style="font-size: 1.1rem; margin-bottom: 1rem;">Click to select or drag and drop</p>
                    <p style="color: var(--text-secondary); font-size: 0.9rem;">Supports: MP3, WAV, OGG, FLAC, AAC, M4A, AIFF</p>
                    <p style="color: var(--primary-color); font-size: 0.9rem; margin-top: 0.5rem; font-weight: 600;">üí° Batch Mode: Select up to 15 files for batch conversion (downloads as ZIP)</p>
                </div>
            </div>
        </div>
        
        <div class="form-group" style="margin-top: 1.5rem;">
            <label class="form-label" for="output_format">Output Format</label>
            <select class="form-select" id="output_format" name="output_format" required>
                <option value="mp3">MP3</option>
                <option value="wav">WAV</option>
                <option value="ogg">OGG</option>
                <option value="flac">FLAC</option>
                <option value="aac">AAC</option>
                <option value="m4a">M4A</option>
                <option value="aiff">AIFF</option>
            </select>
        </div>
        
        <button type="submit" class="btn btn-primary btn-block">Convert & Download</button>
    </form>
    
    <div style="margin-top: 2rem; padding: 1rem; background: var(--surface); border-radius: 6px;">
        <h3>How to use:</h3>
        <ol style="margin-left: 1.5rem; margin-top: 0.5rem;">
            <li>Upload an audio file (MP3, WAV, OGG, FLAC, AAC, M4A, or AIFF)</li>
            <li>Select the desired output format</li>
            <li>Click "Convert & Download"</li>
            <li>Download the converted audio file</li>
        </ol>
        <p style="margin-top: 1rem; color: var(--text-secondary);">
            <strong>Note:</strong> Lossy formats (MP3, OGG, AAC) are converted at 192 kbps quality. Lossless formats (WAV, FLAC) preserve original quality.
        </p>
    </div>
</div>

<a href="{% url 'media_converter:index' %}" class="btn btn-secondary">‚Üê Back to Media Converters</a>
{% endblock %}

{% block extra_js %}
<!-- AUDIO CONVERTER SCRIPT v2.0.2025-01-19 - If you see this comment, the template is loading -->
<script>
// === VERSION CHECK - FORCE CACHE BUST ===
const AUDIO_CONVERTER_VERSION = 'v2.1.2025-01-19-FIXED';
console.log('üîµüîµüîµ AUDIO CONVERTER SCRIPT LOADED - VERSION:', AUDIO_CONVERTER_VERSION);
console.log('üîµ Timestamp:', new Date().toISOString());
console.log('üîµ URL:', window.location.href);
console.log('üîµüîµüîµ CODE FIX: Direct submit handler call (not event dispatch)');
console.log('üîµüîµüîµ CODE FIX: File input handlers restored');

// Version check complete

// === GLOBAL FETCH PROTECTION (runs immediately, before anything else) ===
(function() {
    'use strict';
    if (window._audioConverterFetchProtected) {
        console.error('‚ùå‚ùå‚ùå CRITICAL: Fetch protection already installed - script loaded TWICE!');
        console.trace('Stack trace:');
        return; // Already protected
    }
    window._audioConverterFetchProtected = true;
    console.log('‚úÖ Fetch protection installing...');
    
    const originalFetch = window.fetch;
    let isProcessing = false; // Synchronous lock - no Map needed
    
    window.fetch = function(url, options = {}) {
        const urlString = typeof url === 'string' ? url : (url?.toString() || '');
        const isPost = (options.method || 'GET').toUpperCase() === 'POST';
        // Only block POST requests to the audio converter endpoint (strict check)
        // Parse URL to check pathname only (not query string) to avoid false positives
        let urlPath = urlString;
        try {
            const urlObj = new URL(urlString);
            urlPath = urlObj.pathname; // Only check the path, not query parameters
        } catch (e) {
            // If URL parsing fails, use the original string
            urlPath = urlString;
        }
        const isAudioConverter = urlPath.includes('/media-converter/audio-converter') && 
                                  !urlString.includes('google-analytics') &&
                                  !urlString.includes('gtm');
        
        if (isPost && isAudioConverter) {
            // SYNCHRONOUS CHECK - happens before any async code
            if (isProcessing) {
                console.error('üö´üö´üö´ BLOCKED DUPLICATE FETCH (synchronous lock):', urlString);
                console.trace('Stack trace for blocked request:');
                return Promise.reject(new Error('Duplicate request blocked by synchronous lock'));
            }
            
            // Set lock IMMEDIATELY (synchronously)
            isProcessing = true;
            console.log('‚úÖ ALLOWED FETCH (lock set):', urlString);
            
            // Clean up after request completes (small delay to catch rapid duplicates)
            const fetchPromise = originalFetch.apply(this, arguments);
            fetchPromise.finally(() => {
                // Release lock immediately, but with a tiny delay (100ms) to catch rapid-fire duplicates
                setTimeout(() => {
                    isProcessing = false;
                    console.log('üîì Lock released');
                }, 100);
            });
            
            return fetchPromise;
        }
        
        return originalFetch.apply(this, arguments);
    };
    
    console.log('üõ°Ô∏è Global fetch protection installed (synchronous lock mode)');
    console.log('Current fetch function:', window.fetch);
})();

// === SINGLE EXECUTION GUARD ===
if (window.audioConverterInitialized) {
    console.log('‚ö†Ô∏è Audio converter script already initialized - skipping');
} else {
    window.audioConverterInitialized = true;
    console.log('‚úÖ Audio converter script initializing...');

    document.addEventListener('DOMContentLoaded', () => {
        console.log('üîµ DOMContentLoaded fired');
        const form = document.querySelector('.converter-tool');
        if (!form) {
            console.error('‚ùå Form not found!');
            return;
        }
        console.log('‚úÖ Form found:', form);

        // GLOBAL STATE - shared across all instances
        if (!window._audioConverterState) {
            window._audioConverterState = {
                isProcessing: false,
                downloadTriggered: false,
                abortController: null,
                submitCount: 0
            };
        }
        const state = window._audioConverterState;

        const submitHandler = async (e) => {
            state.submitCount++;
            console.log('üìù Submit handler called, count:', state.submitCount);
            console.log('üìù Event type:', e.type);
            console.log('üìù Event target:', e.target);
            
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();

            // === INSTANT DOUBLE-CLICK PROTECTION ===
            if (state.isProcessing) {
                console.error('üö´üö´üö´ Submit BLOCKED: already processing (count:', state.submitCount, ')');
                return false;
            }

            const fileInput = form.querySelector('#audio_file');
            if (!fileInput?.files?.length) {
                alert('Please select an audio file');
                return false;
            }

            // === LOCK IMMEDIATELY ===
            state.isProcessing = true;
            state.downloadTriggered = false;
            console.log('üîí Lock set, submit count:', state.submitCount);
            
            // Find button by class or any button in the form (since we changed type to "button")
            const submitBtn = form.querySelector('button.btn-primary, button[type="button"], button[type="submit"]');
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.textContent = 'Processing...';
            } else {
                console.error('‚ùå Submit button not found!');
            }
            form.style.pointerEvents = 'none';

            // Abort any previous fetch to kill duplicates
            if (state.abortController) {
                state.abortController.abort();
                console.log('Previous fetch aborted');
            }
            state.abortController = new AbortController(); // Fresh controller

            // Cleanup any old blob URLs
            document.querySelectorAll('a[data-temp-download]').forEach(a => {
                if (a.href.startsWith('blob:')) {
                    URL.revokeObjectURL(a.href);
                }
                a.remove();
            });
        
        const formData = new FormData(form);
        
            try {
                console.log('üì§ About to call fetch...');
                const fetchUrl = form.action || window.location.href;
                console.log('üì§ Fetch URL:', fetchUrl);
                console.log('üì§ FormData keys:', Array.from(formData.keys()));
                console.log('üì§ File in FormData:', formData.get('audio_file')?.name);
                console.log('üì§ Current fetch function:', window.fetch);
                console.log('üì§ Is protected?', window._audioConverterFetchProtected);
                
                const response = await fetch(fetchUrl, {
                    method: 'POST',
                    body: formData,
                    credentials: 'same-origin',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                        'Accept': 'application/json'
                    },
                    signal: state.abortController.signal // Allows abort
                });
                
                console.log('üì• Fetch response received:', response.status);
                console.log('üì• Response headers:', Object.fromEntries(response.headers.entries()));

                let blob, filename, contentType = 'audio/mpeg';

                const contentTypeHeader = response.headers.get('content-type');
                
                if (!response.ok) {
                    // Try to get error message from response
                    let errorMessage = 'Conversion failed';
                    try {
                        if (contentTypeHeader?.includes('application/json')) {
                            const errorData = await response.json();
                            errorMessage = errorData.error || errorData.message || errorMessage;
                        } else {
                            const text = await response.text();
                            // Try to extract error from HTML if it's an error page
                            const errorMatch = text.match(/<div[^>]*class="[^"]*alert[^"]*error[^"]*"[^>]*>([^<]+)<\/div>/i);
                            if (errorMatch) {
                                errorMessage = errorMatch[1].trim();
                            } else if (text.length < 500) {
                                errorMessage = text.substring(0, 200);
                            }
                        }
                    } catch (e) {
                        console.error('Error parsing error response:', e);
                    }
                    throw new Error(errorMessage || `Server returned status ${response.status}`);
                }
                
                // Check if this is a ZIP file (batch conversion)
                if (contentTypeHeader?.includes('application/zip')) {
                    // ZIP format - batch conversion
                    blob = await response.blob();
                    filename = 'converted_audio.zip';
                    contentType = 'application/zip';
                    blob = new Blob([blob], { type: contentType });
                } else if (contentTypeHeader?.includes('application/json')) {
                    // JSON format - single file conversion
                    const data = await response.json();
                    
                    // Check if response contains an error
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    
                    const binary = atob(data.file);
                    const bytes = new Uint8Array(binary.length);
                    for (let i = 0; i < binary.length; i++) {
                        bytes[i] = binary.charCodeAt(i);
                    }
                    blob = new Blob([bytes], { type: data.content_type || 'audio/mpeg' });
                    filename = data.filename;
                    contentType = data.content_type || 'audio/mpeg';
                } else {
                    // Legacy format - direct audio file
                    blob = await response.blob();
                    filename = response.headers.get('x-filename') || 'converted.audio';
                    contentType = response.headers.get('x-content-type') || contentTypeHeader || 'audio/mpeg';
                    blob = new Blob([blob], { type: contentType });
                }

                // === FINAL DUPLICATE DOWNLOAD GUARD ===
                if (state.downloadTriggered) {
                    console.error('üö´üö´üö´ Download already triggered, skipping (submit count:', state.submitCount, ')');
                    return;
                }
                state.downloadTriggered = true;
                console.log('‚úÖ Download triggered (submit count:', state.submitCount, ')');

                // Add timestamp to filename to prevent browser de-duping (only for single files, not ZIP)
                let uniqueFilename = filename;
                if (!filename.endsWith('.zip')) {
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
                    const fileExt = filename.match(/\.[^/.]+$/) || '.mp3';
                    const baseName = filename.replace(/\.[^/.]+$/, '');
                    uniqueFilename = `${baseName}-${timestamp}${fileExt}`;
                }

                const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
                a.download = uniqueFilename; // Use unique name
                a.dataset.tempDownload = 'true';
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            
                // Cleanup
                setTimeout(() => {
                    if (document.body.contains(a)) {
                document.body.removeChild(a);
                    }
                    URL.revokeObjectURL(url);
            }, 100);
            
            } catch (err) {
                // Ignore abort errors (expected for duplicates)
                if (err.name === 'AbortError') {
                    console.log('Fetch aborted (duplicate prevented)');
                    return;
                }
                // Silently ignore duplicate request errors - they're handled by the lock mechanism
                if (err.message && err.message.includes('Duplicate request blocked')) {
                    console.log('Duplicate request blocked (already processing)');
                    return;
                }
                console.error('Conversion error:', err);
                const errorMessage = err.message || 'Conversion failed. Please try again.';
                alert(errorMessage);
                // Don't reload if it's a specific error message - let user try again
                if (errorMessage.includes('Please try again') || errorMessage.length < 20) {
                    window.location.reload();
                }
            } finally {
                // === ALWAYS RESET ===
                console.log('üîì Releasing lock (submit count:', state.submitCount, ')');
                state.isProcessing = false;
                state.downloadTriggered = false; // Reset download flag
                state.abortController = null; // Clear controller
                
                // Find button again (in case form was re-rendered)
                const submitBtn = form.querySelector('button.btn-primary, button[type="button"], button[type="submit"]');
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Convert & Download';
                }
                form.style.pointerEvents = 'auto';
            }
        };

        // DON'T clone the form - it breaks file input handlers
        // Instead, just remove existing submit listeners by replacing the form's submit handler
        const submitBtn = form.querySelector('button.btn-primary');
        
        // Change button type to prevent any native form submission
        if (submitBtn) {
            submitBtn.type = 'button'; // Change from 'submit' to 'button'
            
            // Add click handler that manually triggers our submit handler
            submitBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopImmediatePropagation();
                e.stopPropagation();
                
                if (window._audioConverterState?.isProcessing) {
                    console.error('üö´ Button click blocked: already processing');
                    return false;
                }
                
                console.log('üñ±Ô∏èüñ±Ô∏èüñ±Ô∏è BUTTON CLICKED - CALLING SUBMIT HANDLER DIRECTLY (v2.1 FIX)');
                // Call submit handler directly instead of dispatching event
                const submitEvent = { 
                    type: 'submit',
                    target: form,
                    preventDefault: () => {},
                    stopPropagation: () => {},
                    stopImmediatePropagation: () => {}
                };
                console.log('üñ±Ô∏è About to call submitHandler function...');
                submitHandler(submitEvent);
                console.log('üñ±Ô∏è submitHandler call completed');
            }, { capture: true, once: false });
        }

        // Completely prevent any native form submission
        form.addEventListener('submit', function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
            e.stopPropagation();
            return false;
        }, { capture: true });
        
        // Also set onsubmit to prevent any fallback
        form.onsubmit = function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
            e.stopPropagation();
            return false;
        };
        
        // Attach our handler LAST, with highest priority
        form.addEventListener('submit', submitHandler, { capture: false, once: false });
        
        // Ensure file input is working - main.js should handle it, but verify
        const fileInput = form.querySelector('#audio_file');
        const uploadArea = form.querySelector('.file-upload-area');
        console.log('üìÅ File input found:', fileInput);
        console.log('üìÅ Upload area found:', uploadArea);
        
        if (fileInput && uploadArea) {
            // Make sure file input is accessible
            fileInput.style.display = 'block';
            fileInput.style.opacity = '0';
            fileInput.style.position = 'absolute';
            fileInput.style.width = '100%';
            fileInput.style.height = '100%';
            fileInput.style.cursor = 'pointer';
            
            // Ensure upload area is clickable
            uploadArea.style.cursor = 'pointer';
            uploadArea.style.position = 'relative';
            
            // Add a backup click handler in case main.js didn't attach one
            uploadArea.addEventListener('click', function(e) {
                console.log('üñ±Ô∏è Upload area clicked');
                if (e.target !== fileInput && !fileInput.contains(e.target)) {
                    console.log('üñ±Ô∏è Triggering file input click');
                    fileInput.click();
                }
            }, { capture: false });
            
            // Update display when file is selected
            fileInput.addEventListener('change', (e) => {
                console.log('üìÅ Files selected:', e.target.files.length);
                if (e.target.files.length > 15) {
                    alert('Maximum 15 files allowed for batch conversion. Please select fewer files.');
                    e.target.value = '';
                    return;
                }
                const fileName = e.target.files[0]?.name;
                const p = uploadArea.querySelector('p');
                if (p) {
                    if (e.target.files.length === 1) {
                        p.textContent = 'Selected: ' + fileName;
                    } else {
                        p.textContent = `${e.target.files.length} files selected (will be converted and downloaded as ZIP)`;
                    }
                }
            });
            
            console.log('‚úÖ File input handlers attached');
        } else {
            console.error('‚ùå File input or upload area not found!');
        }
    });
}
</script>
{% endblock extra_js %}