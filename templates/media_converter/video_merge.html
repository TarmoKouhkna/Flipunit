{% extends 'base.html' %}

{% block title %}Merge Video Files Online - Combine Videos Free - {{ SITE_NAME }}{% endblock %}
{% block meta_description %}Free online video merger - Merge multiple video files into one. Combine MP4, AVI, MOV, MKV, WebM, FLV, WMV, and 3GP files. Fast, secure, no registration required.{% endblock %}

{% block content %}
<div class="card">
    <h1 class="card-title">Merge Video Files - Video Merger Online</h1>
    <p>Merge multiple video files into one with trimming and reordering</p>
    
    {% if error %}
    <div class="alert alert-error">{{ error }}</div>
    {% endif %}
    
    <div class="privacy-notice">
        <p>
            <span>üîí</span>
            <span><strong>Privacy Notice:</strong> Your files are processed securely and are <strong>not stored</strong> on our servers.</span>
        </p>
    </div>
    
    <form method="post" enctype="multipart/form-data" id="mergeForm">
        {% csrf_token %}
        <div class="form-group">
            <label class="form-label">Select Video Files (at least 2)</label>
            <div class="file-upload-area" id="uploadArea">
                <input type="file" name="video_files" id="video_files" accept="video/*" multiple>
                <div id="uploadContent">
                    <p style="margin-top: 1rem; font-size: 1.1rem;">üìÅ Click to select or drag and drop multiple files</p>
                    <p style="color: var(--text-secondary); font-size: 0.9rem; margin-top: 0.5rem;">Supports: MP4, AVI, MOV, MKV, WebM, FLV, WMV, 3GP</p>
                </div>
            </div>
        </div>
        
        <!-- Video List with Drag-and-Drop -->
        <div id="videoListContainer" style="margin-top: 2rem; display: none;">
            <h3 style="margin-bottom: 1rem;">Videos to Merge (drag to reorder)</h3>
            <div id="videoList" style="display: flex; flex-direction: column; gap: 1rem;"></div>
        </div>
        
        <!-- Preview Section -->
        <div id="previewSection" style="margin-top: 2rem; display: none;">
            <h3 style="margin-bottom: 1rem;">Preview Merged Video</h3>
            <div style="background: var(--surface); padding: 1rem; border-radius: 6px;">
                <video id="previewVideo" controls style="width: 100%; max-width: 800px; border-radius: 4px; margin: 0 auto; display: block;" preload="metadata">
                    Your browser does not support the video tag.
                </video>
                <div style="margin-top: 1rem; display: flex; gap: 1rem;">
                    <button type="button" class="btn btn-primary" id="downloadBtn" style="display: none;">Download Merged Video</button>
                    <button type="button" class="btn btn-secondary" id="backToEditBtn" style="display: none;">Edit Again</button>
                </div>
            </div>
        </div>
        
        <!-- Action Buttons -->
        <div id="actionButtons" style="margin-top: 1.5rem; display: flex; gap: 1rem;">
            <button type="button" class="btn btn-primary" id="mergePreviewBtn" style="display: none;">Merge & Preview</button>
        </div>
    </form>
    
    <div style="margin-top: 2rem; padding: 1rem; background: var(--surface); border-radius: 6px;">
        <h3>How to use:</h3>
        <ol class="list-indent" style="margin-top: 0.5rem; color: var(--text-secondary); line-height: 1.8;">
            <li>Select multiple video files (hold Ctrl/Cmd to select multiple)</li>
            <li>Trim each video if needed (set start and end times)</li>
            <li>Drag videos to reorder them</li>
            <li>Click "Merge & Preview" to see the result</li>
            <li>If satisfied, click "Download Merged Video"</li>
        </ol>
    </div>
</div>

<a href="{% url 'media_converter:index' %}" class="btn btn-secondary">‚Üê Back to Media Converters</a>

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const form = document.getElementById('mergeForm');
    const fileInput = document.getElementById('video_files');
    const uploadArea = document.getElementById('uploadArea');
    const videoListContainer = document.getElementById('videoListContainer');
    const videoList = document.getElementById('videoList');
    const previewSection = document.getElementById('previewSection');
    const previewVideo = document.getElementById('previewVideo');
    const mergePreviewBtn = document.getElementById('mergePreviewBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const backToEditBtn = document.getElementById('backToEditBtn');
    const actionButtons = document.getElementById('actionButtons');
    
    let videoFiles = [];
    let mergedVideoBlob = null;
    let mergedVideoFilename = null;
    let isProcessing = false;
    
    // Video file object structure
    function createVideoFile(file, index) {
        // Use a more reliable ID generation that avoids floating point precision issues
        // Store ID as string to ensure consistent matching
        const id = String(Date.now()) + '_' + String(Math.random()).substring(2);
        return {
            file: file,
            index: index,
            id: id, // Store as string for consistent matching
            startTime: 0,
            endTime: null, // null means use full video
            duration: null, // will be set after loading
            previewUrl: null
        };
    }
    
    // Create video item HTML
    function createVideoItem(videoFile) {
        const item = document.createElement('div');
        item.className = 'video-item';
        item.draggable = true;
        // Ensure ID is set as string and matches videoFile.id exactly
        const idToSet = String(videoFile.id);
        item.dataset.id = idToSet;
        // Double-check it was set correctly
        if (item.dataset.id !== idToSet) {
            console.error(`Failed to set dataset.id: wanted ${idToSet}, got ${item.dataset.id}`);
        }
        item.style.cssText = 'background: var(--surface); padding: 1rem; border-radius: 6px; border: 2px solid var(--border-color); cursor: move; position: relative;';
        
        const fileSizeMB = (videoFile.file.size / (1024 * 1024)).toFixed(1);
        const durationText = videoFile.duration ? `(${formatTime(videoFile.duration)}s)` : '';
        
        item.innerHTML = `
            <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">
                <span style="font-size: 1.5rem; cursor: move; flex-shrink: 0;">‚ò∞</span>
                <div style="flex: 1; min-width: 0;">
                    <strong style="word-break: break-word;">${videoFile.file.name}</strong>
                    <span style="color: var(--text-secondary); display: block; font-size: 0.9rem; margin-top: 0.25rem;">${fileSizeMB} MB ${durationText}</span>
                </div>
                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; flex-shrink: 0;">
                    <button type="button" class="preview-video-btn">‚ñ∂ Preview & Trim</button>
                    <button type="button" class="remove-video-btn">Remove</button>
                </div>
            </div>
            <div class="video-time-inputs" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                <div>
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Start Time (seconds)</label>
                    <input type="number" class="start-time" step="0.1" min="0" value="${videoFile.startTime}">
                </div>
                <div>
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">End Time (seconds, leave empty for full video)</label>
                    <input type="number" class="end-time" step="0.1" min="0" value="${videoFile.endTime || ''}" placeholder="Full video">
                </div>
            </div>
            <div style="margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-secondary);">
                Duration: <span class="trim-duration">${videoFile.endTime ? formatTime(videoFile.endTime - videoFile.startTime) : 'Full'}</span>
            </div>
        `;
        
        // Duration will be loaded by loadMetadataSequentially to prevent overload
        // Just show placeholder for now
        if (videoFile.duration) {
            const durationSpan = item.querySelector('.trim-duration');
            if (durationSpan) {
                const endTime = videoFile.endTime || videoFile.duration;
                durationSpan.textContent = formatTime(endTime - videoFile.startTime);
            }
        }
        
        // Event listeners
        const startTimeInput = item.querySelector('.start-time');
        const endTimeInput = item.querySelector('.end-time');
        const removeBtn = item.querySelector('.remove-video-btn');
        const previewBtn = item.querySelector('.preview-video-btn');
        
        startTimeInput.addEventListener('input', function() {
            // Normalize comma to dot for decimal separator
            const normalizedValue = this.value.replace(',', '.');
            videoFile.startTime = parseFloat(normalizedValue) || 0;
            // Update input if value was changed
            if (this.value !== normalizedValue) {
                this.value = normalizedValue;
            }
            updateTrimDuration(item, videoFile);
        });
        
        endTimeInput.addEventListener('input', function() {
            // Normalize comma to dot for decimal separator
            const normalizedValue = this.value.replace(',', '.');
            videoFile.endTime = normalizedValue ? parseFloat(normalizedValue) : null;
            // Update input if value was changed
            if (this.value !== normalizedValue) {
                this.value = normalizedValue;
            }
            updateTrimDuration(item, videoFile);
        });
        
        if (removeBtn) {
            let removeHandled = false;
            
            function handleRemove(e) {
                if (removeHandled) return;
                removeHandled = true;
                console.log('Remove button clicked for video:', videoFile.id);
                
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                
                // Small delay to ensure UI updates
                setTimeout(() => {
                    removeVideo(videoFile.id);
                    removeHandled = false;
                }, 50);
            }
            
            // Use touchstart for iOS to catch it before any zoom happens
            removeBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                e.stopPropagation();
                handleRemove(e);
            }, { passive: false });
            
            // Also listen for click events (for desktop and as fallback)
            removeBtn.addEventListener('click', function(e) {
                if (!removeHandled) {
                    handleRemove(e);
                }
            });
        } else {
            console.error('Remove button not found for video:', videoFile.id);
        }
        
        previewBtn.addEventListener('click', function() {
            showVideoPreview(videoFile, item);
        });
        
        // Drag and drop
        item.addEventListener('dragstart', handleDragStart);
        item.addEventListener('dragover', handleDragOver);
        item.addEventListener('drop', handleDrop);
        item.addEventListener('dragend', handleDragEnd);
        
        return item;
    }
    
    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
    
    function updateTrimDuration(item, videoFile) {
        const durationSpan = item.querySelector('.trim-duration');
        if (durationSpan && videoFile.duration) {
            const endTime = videoFile.endTime || videoFile.duration;
            const duration = Math.max(0, endTime - videoFile.startTime);
            durationSpan.textContent = formatTime(duration);
        }
    }
    
    // Cleanup function moved below
    
    function updateVideoList() {
        videoList.innerHTML = '';
        videoFiles.forEach((videoFile, index) => {
            videoFile.index = index;
            const item = createVideoItem(videoFile);
            // Verify ID was set correctly
            const expectedId = String(videoFile.id);
            const actualId = String(item.dataset.id);
            if (actualId !== expectedId) {
                console.error(`ID mismatch in updateVideoList [${index}]: videoFile.id=${expectedId}, item.dataset.id=${actualId}`);
                item.dataset.id = expectedId; // Force set it
            }
            videoList.appendChild(item);
        });
        
        // Debug: Log IDs after updateVideoList
        console.log('After updateVideoList - videoFiles IDs:', videoFiles.map(vf => vf.id));
        console.log('After updateVideoList - DOM IDs:', Array.from(videoList.querySelectorAll('.video-item')).map(item => item.dataset.id));
        
        if (videoFiles.length >= 2) {
            mergePreviewBtn.style.display = 'block';
        } else {
            mergePreviewBtn.style.display = 'none';
        }
    }
    
    // Drag and drop handlers
    let draggedElement = null;
    
    function handleDragStart(e) {
        draggedElement = this;
        this.style.opacity = '0.5';
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', this.innerHTML);
    }
    
    function handleDragOver(e) {
        if (e.preventDefault) {
            e.preventDefault();
        }
        e.dataTransfer.dropEffect = 'move';
        return false;
    }
    
    function handleDrop(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
        }
        
            if (draggedElement !== this) {
                const draggedId = draggedElement.dataset.id;
                const targetId = this.dataset.id;
                
                // Use string comparison since IDs are now strings
                const draggedIndex = videoFiles.findIndex(vf => String(vf.id) === String(draggedId));
                const targetIndex = videoFiles.findIndex(vf => String(vf.id) === String(targetId));
            
            if (draggedIndex !== -1 && targetIndex !== -1) {
                const [removed] = videoFiles.splice(draggedIndex, 1);
                videoFiles.splice(targetIndex, 0, removed);
                
                // Debug: Log reordering
                console.log(`Reordered: moved ${removed.file.name} from index ${draggedIndex} to ${targetIndex}`);
                console.log('New order:', videoFiles.map((vf, idx) => `${idx}: ${vf.file.name}`));
                
                updateVideoList();
            }
        }
        
        return false;
    }
    
    function handleDragEnd(e) {
        this.style.opacity = '1';
        draggedElement = null;
    }
    
    // File input handler - limit concurrent metadata loading
    fileInput.addEventListener('change', function(e) {
        const newFiles = Array.from(e.target.files);
        const startIndex = videoFiles.length;
        newFiles.forEach(file => {
            const videoFile = createVideoFile(file, videoFiles.length);
            videoFiles.push(videoFile);
        });
        updateVideoList();
        videoListContainer.style.display = 'block';
        
        // Load metadata sequentially to avoid overwhelming browser
        loadMetadataSequentially(startIndex);
    });
    
    // Load video metadata sequentially to prevent browser overload
    function loadMetadataSequentially(startIndex) {
        let currentIndex = startIndex || 0;
        const maxConcurrent = 2; // Load max 2 videos at a time
        let activeLoads = 0;
        
        function loadNext() {
            if (currentIndex >= videoFiles.length) return;
            if (activeLoads >= maxConcurrent) {
                setTimeout(loadNext, 200);
                return;
            }
            
            const videoFile = videoFiles[currentIndex];
            if (!videoFile.duration) {
                activeLoads++;
                const video = document.createElement('video');
                video.preload = 'metadata';
                const tempUrl = URL.createObjectURL(videoFile.file);
                video.src = tempUrl;
                
                video.onloadedmetadata = function() {
                    videoFile.duration = video.duration;
                    URL.revokeObjectURL(tempUrl);
                    video.src = '';
                    activeLoads--;
                    
                    // Update UI if item exists
                    const item = document.querySelector(`[data-id="${videoFile.id}"]`);
                    if (item) {
                        const durationSpan = item.querySelector('.trim-duration');
                        if (durationSpan) {
                            const endTime = videoFile.endTime || videoFile.duration;
                            durationSpan.textContent = formatTime(endTime - videoFile.startTime);
                        }
                        // Update duration text in header
                        const headerText = item.querySelector('strong').nextSibling;
                        if (headerText && headerText.textContent) {
                            const fileSizeMB = (videoFile.file.size / (1024 * 1024)).toFixed(1);
                            headerText.textContent = ` ${fileSizeMB} MB (${formatTime(videoFile.duration)}s)`;
                        }
                    }
                    
                    currentIndex++;
                    setTimeout(loadNext, 100); // Small delay between loads
                };
                
                video.onerror = function() {
                    URL.revokeObjectURL(tempUrl);
                    video.src = '';
                    activeLoads--;
                    currentIndex++;
                    setTimeout(loadNext, 100);
                };
            } else {
                currentIndex++;
                setTimeout(loadNext, 50);
            }
        }
        
        // Start loading
        for (let i = 0; i < Math.min(maxConcurrent, videoFiles.length - startIndex); i++) {
            setTimeout(() => loadNext(), i * 200);
        }
    }
    
    // Drag and drop file upload
    uploadArea.addEventListener('dragover', function(e) {
        e.preventDefault();
        uploadArea.style.borderColor = 'var(--primary-color)';
    });
    
    uploadArea.addEventListener('drop', function(e) {
        e.preventDefault();
        uploadArea.style.borderColor = 'var(--border-color)';
        const files = e.dataTransfer.files;
        const videoFilesArray = Array.from(files).filter(f => f.type.startsWith('video/'));
        if (videoFilesArray.length > 0) {
            const startIndex = videoFiles.length;
            videoFilesArray.forEach(file => {
                const videoFile = createVideoFile(file, videoFiles.length);
                videoFiles.push(videoFile);
            });
            updateVideoList();
            videoListContainer.style.display = 'block';
            // Load metadata sequentially
            loadMetadataSequentially(startIndex);
        }
    });
    
    // Merge and preview
    mergePreviewBtn.addEventListener('click', async function() {
        if (isProcessing || videoFiles.length < 2) {
            return;
        }
        
        // Prevent multiple clicks
        if (mergePreviewBtn.disabled) {
            return;
        }
        
        isProcessing = true;
        mergePreviewBtn.disabled = true;
        mergePreviewBtn.textContent = 'Merging videos...';
        mergePreviewBtn.style.opacity = '0.6';
        mergePreviewBtn.style.cursor = 'not-allowed';
        
        // Disable all video items during processing
        videoList.querySelectorAll('.video-item').forEach(item => {
            item.style.pointerEvents = 'none';
            item.style.opacity = '0.6';
        });
        
        // Declare progress variables at function scope for access in finally block
        let progressBar = null;
        let progressText = null;
        let progressInterval = null;
        
        // Show progress indicator
        const progressDiv = document.createElement('div');
        progressDiv.id = 'mergeProgress';
        progressDiv.className = 'merge-progress-modal';
        progressDiv.innerHTML = `
            <div class="merge-progress-title">
                <strong>Processing ${videoFiles.length} video(s)...</strong>
            </div>
            <div class="merge-progress-bar-container">
                <div id="progressBar" class="merge-progress-bar"></div>
            </div>
            <div id="progressText" class="merge-progress-text">
                Preparing files...
            </div>
        `;
        actionButtons.insertAdjacentElement('afterend', progressDiv);
        
        // Get progress elements
        progressBar = document.getElementById('progressBar');
        progressText = document.getElementById('progressText');
        
        // Simulate progress (we can't get real progress from FFmpeg easily, so we estimate)
        let progressPercent = 0;
        if (progressBar && progressText) {
            progressInterval = setInterval(() => {
                if (progressPercent < 90) {
                    progressPercent += 2;
                    progressBar.style.width = progressPercent + '%';
                    if (progressPercent < 30) {
                        progressText.textContent = 'Preparing files...';
                    } else if (progressPercent < 60) {
                        progressText.textContent = 'Processing videos...';
                    } else {
                        progressText.textContent = 'Merging and encoding...';
                    }
                }
            }, 500);
        }
        
        try {
            const formData = new FormData();
            formData.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);
            formData.append('action', 'preview');
            
            // Add files in order (videoFiles array order matches display order after drag-and-drop)
            // Use explicit index in field name to guarantee order preservation
            formData.append('file_count', String(videoFiles.length));
            
            // IMPORTANT: Read trim values from current input fields and send files in DOM order
            // This ensures we get the latest values and correct order even if updateVideoList was called
            const videoItems = Array.from(videoList.querySelectorAll('.video-item'));
            
            // Debug: Log all videoFiles and their IDs (expanded)
            console.log('All videoFiles:');
            videoFiles.forEach((vf, idx) => {
                console.log(`  [${idx}] id=${vf.id} (${typeof vf.id}), name=${vf.file.name}, startTime=${vf.startTime}, endTime=${vf.endTime}`);
            });
            console.log('All DOM items:');
            videoItems.forEach((item, idx) => {
                const fileName = item.querySelector('strong') ? item.querySelector('strong').textContent.trim() : 'unknown';
                console.log(`  [${idx}] id=${item.dataset.id} (${typeof item.dataset.id}), fileName=${fileName}`);
            });
            
            // Build ordered list by matching DOM order with videoFiles array
            // Use filename as fallback if ID matching fails (since IDs might not match after DOM recreation)
            const orderedVideoFiles = [];
            videoItems.forEach((item, idx) => {
                const videoId = item.dataset.id;
                // Try to find by ID first
                let videoFile = videoFiles.find(vf => String(vf.id) === String(videoId));
                
                // If ID match fails, try matching by filename (more reliable fallback)
                if (!videoFile) {
                    const fileNameElement = item.querySelector('strong');
                    if (fileNameElement) {
                        const fileName = fileNameElement.textContent.trim();
                        videoFile = videoFiles.find(vf => vf.file.name === fileName);
                        if (videoFile) {
                            console.log(`ID match failed for item ${idx}, matched by filename: ${fileName}`);
                        }
                    }
                }
                
                if (videoFile) {
                    // Read trim values from input fields
                    const startInput = item.querySelector('.start-time');
                    const endInput = item.querySelector('.end-time');
                    if (startInput) {
                        const normalizedValue = startInput.value.replace(',', '.');
                        videoFile.startTime = parseFloat(normalizedValue) || 0;
                    }
                    if (endInput && endInput.value && endInput.value.trim()) {
                        const normalizedValue = endInput.value.replace(',', '.');
                        videoFile.endTime = parseFloat(normalizedValue) || null;
                    } else if (endInput) {
                        videoFile.endTime = null;
                    }
                    orderedVideoFiles.push(videoFile);
                } else {
                    console.error(`Video file not found for DOM item ${idx}, id=${videoId}`);
                    // Try to get filename for better error message
                    const fileNameElement = item.querySelector('strong');
                    const fileName = fileNameElement ? fileNameElement.textContent.trim() : 'unknown';
                    console.error(`  Looking for file: ${fileName}`);
                    console.error(`  Available files: ${videoFiles.map(vf => vf.file.name).join(', ')}`);
                }
            });
            
            // Debug: Log the order and trim values before sending
            console.log('Sending files in order:');
            orderedVideoFiles.forEach((vf, idx) => {
                console.log(`  Index ${idx}: ${vf.file.name}, start=${vf.startTime}, end=${vf.endTime}`);
            });
            
            // Send files in the exact order they appear in the DOM (which matches user's reordering)
            orderedVideoFiles.forEach((videoFile, index) => {
                // Use explicit index in field name to guarantee order preservation
                formData.append(`video_file_${index}`, videoFile.file);
                // Ensure numeric values are sent as strings (normalize comma to dot)
                const startTime = String(videoFile.startTime || 0).replace(',', '.');
                const endTime = (videoFile.endTime !== null && videoFile.endTime !== undefined) ? String(videoFile.endTime).replace(',', '.') : '';
                
                console.log(`Sending file ${index}: ${videoFile.file.name}, start_time=${startTime}, end_time=${endTime || '(empty)'}`);
                
                formData.append(`start_time_${index}`, startTime);
                // Always send end_time field, even if empty (so backend knows it's not set)
                formData.append(`end_time_${index}`, endTime);
            });
            
            const response = await fetch(window.location.href, {
                method: 'POST',
                body: formData,
                credentials: 'same-origin'
            });
            
            if (!response.ok) {
                throw new Error('Merge failed');
            }
            
            const contentType = response.headers.get('content-type') || '';
            if (contentType.includes('video/')) {
                // Update progress to 100%
                if (progressBar) {
                    progressBar.style.width = '100%';
                }
                if (progressText) {
                    progressText.textContent = 'Complete!';
                }
                
                mergedVideoBlob = await response.blob();
                mergedVideoFilename = response.headers.get('x-filename') || 'merged_video.mp4';
                
                const videoUrl = URL.createObjectURL(mergedVideoBlob);
                previewVideo.src = videoUrl;
                previewSection.style.display = 'block';
                downloadBtn.style.display = 'block';
                backToEditBtn.style.display = 'block';
                actionButtons.style.display = 'none';
                
                // Scroll to preview
                previewSection.scrollIntoView({ behavior: 'smooth' });
            } else {
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const errorDiv = doc.querySelector('.alert-error');
                const errorMessage = errorDiv ? errorDiv.textContent.trim() : 'Merge failed.';
                throw new Error(errorMessage);
            }
        } catch (error) {
            alert('Error: ' + error.message);
        } finally {
            // Clear progress interval
            if (progressInterval !== null) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
            
            // Remove progress indicator
            const progressDiv = document.getElementById('mergeProgress');
            if (progressDiv) {
                progressDiv.remove();
            }
            
            isProcessing = false;
            mergePreviewBtn.disabled = false;
            mergePreviewBtn.textContent = 'Merge & Preview';
            mergePreviewBtn.style.opacity = '1';
            mergePreviewBtn.style.cursor = 'pointer';
            
            // Re-enable video items
            videoList.querySelectorAll('.video-item').forEach(item => {
                item.style.pointerEvents = 'auto';
                item.style.opacity = '1';
            });
        }
    });
    
    // Download
    downloadBtn.addEventListener('click', function() {
        if (!mergedVideoBlob) return;
        
        const url = URL.createObjectURL(mergedVideoBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = mergedVideoFilename;
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();
        
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
    });
    
    // Back to edit
    backToEditBtn.addEventListener('click', function() {
        previewSection.style.display = 'none';
        actionButtons.style.display = 'flex';
        if (previewVideo.src && previewVideo.src.startsWith('blob:')) {
            URL.revokeObjectURL(previewVideo.src);
        }
        previewVideo.src = '';
        mergedVideoBlob = null;
        mergedVideoFilename = null;
    });
    
    // Show individual video preview with trim controls (client-side, no server processing)
    function showVideoPreview(videoFile, itemElement) {
        // Prevent opening multiple modals
        const existingModal = document.getElementById('videoPreviewModal');
        if (existingModal) {
            return;
        }
        
        // Create modal
        const modal = document.createElement('div');
        modal.id = 'videoPreviewModal';
        modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(15, 23, 42, 0.75); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); z-index: 99999; display: flex; align-items: center; justify-content: center; touch-action: manipulation; -webkit-overflow-scrolling: touch; animation: fadeIn 0.2s ease;';
        
        // Create blob URL for original video (reuse if exists)
        // iOS Safari and macOS Safari have issues with blob URLs from File objects
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        console.log('Device detection - isIOS:', isIOS, 'isSafari:', isSafari, 'isMobile:', isMobile);
        
        // Safari (all platforms) works better with server-side preview
        if (!videoFile.previewUrl && !isIOS && !isMobile && !isSafari) {
            try {
                videoFile.previewUrl = URL.createObjectURL(videoFile.file);
                console.log('Created blob URL for preview');
            } catch (e) {
                console.warn('Failed to create blob URL:', e);
                videoFile.previewUrl = null;
            }
        } else {
            console.log('Skipping client-side blob URL (mobile/Safari detected)');
        }
        
        modal.innerHTML = `
            <div class="hybrid-modal-content">
                <h3 class="hybrid-modal-title">Preview & Trim: ${videoFile.file.name}</h3>
                <button id="closePreview" class="btn btn-secondary hybrid-modal-close" aria-label="Close">‚úï</button>
                <div id="videoPreviewContainer" class="hybrid-video-container">
                    <video id="previewPlayer" controls preload="metadata" playsinline class="hybrid-video-player"></video>
                    <div id="videoError" class="hybrid-video-error" style="display: none;">
                        <p class="error-title">Video preview unavailable</p>
                        <p class="error-message">You can still set trim times manually below. The trim will be applied when merging.</p>
                    </div>
                    <div id="trimOverlay" class="trim-overlay"></div>
                    <div id="trimStartMarker" class="trim-marker trim-start"></div>
                    <div id="trimEndMarker" class="trim-marker trim-end"></div>
                </div>
                <div class="hybrid-modal-inputs">
                    <div class="form-group">
                        <label class="form-label">Start Time (seconds)</label>
                        <input type="number" id="previewStartTime" step="0.1" min="0" value="${videoFile.startTime}" class="form-control modal-input">
                        <button type="button" id="setStartFromPlayer" class="btn btn-primary modal-btn">Set from Player Position</button>
                    </div>
                    <div class="form-group">
                        <label class="form-label">End Time (seconds, leave empty for full video)</label>
                        <input type="number" id="previewEndTime" step="0.1" min="0" value="${videoFile.endTime || ''}" placeholder="Full video" class="form-control modal-input">
                        <button type="button" id="setEndFromPlayer" class="btn btn-primary modal-btn">Set from Player Position</button>
                    </div>
                </div>
                <div class="privacy-notice hybrid-modal-tip">
                    <p id="modalTipText">
                        <strong>üí° Tip:</strong> Play the video and use the buttons above to set trim points from the current playback position. 
                        The trim will be applied when you merge the videos.
                    </p>
                </div>
                <div class="hybrid-modal-actions">
                    <button id="applyTrim" type="button" class="btn btn-primary hybrid-apply-btn">Apply Trim</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        const previewPlayer = modal.querySelector('#previewPlayer');
        const previewStartTime = modal.querySelector('#previewStartTime');
        const previewEndTime = modal.querySelector('#previewEndTime');
        const applyTrimBtn = modal.querySelector('#applyTrim');
        const closeBtn = modal.querySelector('#closePreview');
        const setStartBtn = modal.querySelector('#setStartFromPlayer');
        const setEndBtn = modal.querySelector('#setEndFromPlayer');
        const trimStartMarker = modal.querySelector('#trimStartMarker');
        const trimEndMarker = modal.querySelector('#trimEndMarker');
        const trimOverlay = modal.querySelector('#trimOverlay');
        const videoError = modal.querySelector('#videoError');
        const modalTipText = modal.querySelector('#modalTipText');
        
        // Set video attributes for better compatibility
        previewPlayer.setAttribute('playsinline', '');
        previewPlayer.setAttribute('webkit-playsinline', '');
        previewPlayer.setAttribute('x5-playsinline', ''); // For Android
        previewPlayer.muted = false;
        previewPlayer.setAttribute('controls', '');
        
        // Check file type - some browsers don't support .mov directly
        const fileName = videoFile.file.name.toLowerCase();
        const isMovFile = fileName.endsWith('.mov');
        let useServerPreview = isIOS; // Use server preview for iOS immediately
        
        // Try client-side first, fallback to server if needed
        function tryClientSidePreview() {
            if (!videoFile.previewUrl) {
                console.log('No preview URL available, using server preview');
                tryServerPreview();
                return;
            }
            try {
                previewPlayer.src = videoFile.previewUrl;
                previewPlayer.load();
            } catch (e) {
                console.error('Error setting video src:', e);
                tryServerPreview();
            }
        }
        
        function tryServerPreview() {
            console.log('Starting server preview for:', videoFile.file.name);
            const fileSizeMB = (videoFile.file.size / (1024 * 1024)).toFixed(1);
            videoError.innerHTML = `<p class="error-title">‚è≥ Loading preview from server...</p><p class="error-message">File size: ${fileSizeMB}MB. This may take a moment.</p>`;
            videoError.style.display = 'block';
            previewPlayer.style.display = 'none';
            
            loadServerPreview(videoFile, previewPlayer).then(() => {
                console.log('Server preview loaded successfully');
                // Force video to show
                videoError.style.display = 'none';
                previewPlayer.style.display = 'block';
                previewPlayer.style.visibility = 'visible';
                previewPlayer.style.opacity = '1';
                
                // Ensure the video container is visible
                const videoContainer = previewPlayer.closest('.hybrid-video-container');
                if (videoContainer) {
                    videoContainer.style.minHeight = 'auto';
                }
                
                // Update trim markers with loaded duration
                updateTrimMarkers();
            }).catch(err => {
                console.error('Server preview error:', err);
                // Show error but allow manual trimming
                videoError.innerHTML = `
                    <p class="error-title">‚ö†Ô∏è Preview unavailable</p>
                    <p class="error-message">${err.message || 'Could not load preview'}</p>
                    <p class="error-message">You can still set trim times manually. The trim will be applied when merging.</p>
                `;
                videoError.style.display = 'block';
                previewPlayer.style.display = 'none';
            });
        }
        
        // Handle video loading errors
        previewPlayer.addEventListener('error', function(e) {
            console.error('Video load error:', previewPlayer.error);
            const errorCode = previewPlayer.error ? previewPlayer.error.code : 'unknown';
            
            // If client-side fails and it's a MOV file, try server-side preview
            if (isMovFile && errorCode === 4 && !useServerPreview) {
                useServerPreview = true;
                tryServerPreview();
                return;
            }
            
            previewPlayer.style.display = 'none';
            videoError.innerHTML = `
                <p class="error-title">üìπ Video preview unavailable</p>
                <p class="error-message">You can still set trim times manually below. The trim will be applied when merging.</p>
            `;
            videoError.style.display = 'block';
        });
        
        // Handle successful load
        previewPlayer.addEventListener('loadeddata', function() {
            console.log('Video loadeddata event fired');
            videoError.style.display = 'none';
            previewPlayer.style.display = 'block';
            previewPlayer.style.visibility = 'visible';
            previewPlayer.style.opacity = '1';
        });
        
        // Update trim markers when video metadata is loaded
        previewPlayer.addEventListener('loadedmetadata', function() {
            if (!videoFile.duration && previewPlayer.duration && isFinite(previewPlayer.duration)) {
                videoFile.duration = previewPlayer.duration;
            }
            updateTrimMarkers();
        });
        
        // Also try on canplay event
        previewPlayer.addEventListener('canplay', function() {
            if (!videoFile.duration && previewPlayer.duration && isFinite(previewPlayer.duration)) {
                videoFile.duration = previewPlayer.duration;
            }
            updateTrimMarkers();
        });
        
        // For iOS and Safari, skip video preview and just show manual input
        // Safari has known issues with video blob URLs
        if (isIOS || isSafari) {
            console.log('iOS/Safari detected - showing manual trim input only (no video preview)');
            videoError.innerHTML = `
                <p class="error-title">‚úèÔ∏è Manual Trim Mode (Safari)</p>
                <p class="error-message">Video preview is not supported in Safari due to browser limitations.</p>
                <p class="error-message"><strong>üí° Tip:</strong> Open your video in QuickTime Player or another app to find the exact start and end times you want, then enter them below.</p>
                <p class="error-message">Leave end time empty to use the full video from the start time.</p>
            `;
            videoError.style.display = 'block';
            previewPlayer.style.display = 'none';
            
            // Update the tip text for manual mode
            if (modalTipText) {
                modalTipText.innerHTML = `
                    <strong>üìù How to trim:</strong> Enter the start time (in seconds) where you want your clip to begin, 
                    and optionally an end time where you want it to finish. For example, enter 5 for start and 15 for end 
                    to keep seconds 5-15 of your video. Leave end time empty to keep everything from the start time to the end.
                `;
            }
            
            // Don't try to load preview
            useServerPreview = false;
        } else if (isMobile || isMovFile) {
            // Mobile and MOV files use server preview
            console.log('Using server preview for Mobile/MOV file');
            useServerPreview = true;
            // Small delay to ensure modal is rendered
            setTimeout(() => {
                tryServerPreview();
            }, 100);
        } else {
            // Try client-side first for supported formats (Chrome, Firefox, Edge)
            tryClientSidePreview();
            
            // Fallback to server preview if client-side fails
            setTimeout(() => {
                if (previewPlayer.readyState === 0 || previewPlayer.error) {
                    console.log('Client preview failed, trying server preview');
                    if (!useServerPreview) {
                        useServerPreview = true;
                        tryServerPreview();
                    }
                }
            }, 2000);
        }
        
        // Update trim markers when values change
        function updateTrimMarkers() {
            // Try to get duration from video element if not set
            if (!videoFile.duration && previewPlayer.duration && isFinite(previewPlayer.duration)) {
                videoFile.duration = previewPlayer.duration;
            }
            
            if (!videoFile.duration || videoFile.duration <= 0) {
                // Duration not available yet, hide markers
                trimStartMarker.style.display = 'none';
                trimEndMarker.style.display = 'none';
                trimOverlay.style.display = 'none';
                return;
            }
            
            const videoRect = previewPlayer.getBoundingClientRect();
            const startPercent = Math.max(0, Math.min(100, (videoFile.startTime / videoFile.duration) * 100));
            const endPercent = videoFile.endTime ? Math.max(0, Math.min(100, (videoFile.endTime / videoFile.duration) * 100)) : 100;
            
            trimStartMarker.style.left = startPercent + '%';
            trimStartMarker.style.display = 'block';
            trimEndMarker.style.left = endPercent + '%';
            trimEndMarker.style.display = videoFile.endTime ? 'block' : 'none';
            trimOverlay.style.left = startPercent + '%';
            trimOverlay.style.width = Math.max(0, endPercent - startPercent) + '%';
            trimOverlay.style.display = 'block';
        }
        
        // Set start time from player position
        setStartBtn.addEventListener('click', function() {
            const currentTime = previewPlayer.currentTime;
            previewStartTime.value = currentTime.toFixed(1);
            videoFile.startTime = currentTime;
            updateTrimMarkers();
        });
        
        // Set end time from player position
        setEndBtn.addEventListener('click', function() {
            const currentTime = previewPlayer.currentTime;
            previewEndTime.value = currentTime.toFixed(1);
            videoFile.endTime = currentTime;
            updateTrimMarkers();
        });
        
        // Update trim markers when inputs change
        previewStartTime.addEventListener('input', function() {
            // Normalize comma to dot for decimal separator
            const normalizedValue = this.value.replace(',', '.');
            videoFile.startTime = parseFloat(normalizedValue) || 0;
            // Update input if value was changed
            if (this.value !== normalizedValue) {
                this.value = normalizedValue;
            }
            updateTrimMarkers();
        });
        
        previewEndTime.addEventListener('input', function() {
            // Normalize comma to dot for decimal separator
            const normalizedValue = this.value.replace(',', '.');
            videoFile.endTime = normalizedValue ? parseFloat(normalizedValue) : null;
            // Update input if value was changed
            if (this.value !== normalizedValue) {
                this.value = normalizedValue;
            }
            updateTrimMarkers();
        });
        
        // Initial marker update
        setTimeout(updateTrimMarkers, 100);
        
        // Close modal function - defined first so it can be used by other functions
        const closeModal = function(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            console.log('Closing modal');
            
            // Clean up video
            if (previewPlayer.src) {
                previewPlayer.pause();
                previewPlayer.src = '';
            }
            
            // Remove modal from DOM
            if (modal && modal.parentNode) {
                document.body.removeChild(modal);
            }
        };
        
        // Apply trim and close - use both click and touchstart for iOS compatibility
        function applyTrim(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            console.log('Apply Trim clicked');
            // Normalize comma to dot for decimal separator
            const startValue = previewStartTime.value.replace(',', '.');
            const endValue = previewEndTime.value ? previewEndTime.value.replace(',', '.') : '';
            const start = parseFloat(startValue) || 0;
            const end = endValue ? parseFloat(endValue) : null;
            videoFile.startTime = start;
            videoFile.endTime = end;
            
            console.log('Trim values:', { start, end });
            
            // Update the form inputs
            const startInput = itemElement.querySelector('.start-time');
            const endInput = itemElement.querySelector('.end-time');
            if (startInput) startInput.value = start;
            if (endInput) endInput.value = end || '';
            updateTrimDuration(itemElement, videoFile);
            
            // Close the modal
            closeModal();
        }
        
        if (applyTrimBtn) {
            applyTrimBtn.addEventListener('click', applyTrim);
            // Also listen for touch events on iOS
            applyTrimBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                e.stopPropagation();
                applyTrim(e);
            });
        } else {
            console.error('Apply Trim button not found!');
        }
        
        // Close button - multiple event types for better compatibility
        if (closeBtn) {
            closeBtn.addEventListener('click', closeModal);
            closeBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                closeModal(e);
            });
        } else {
            console.error('Close button not found!');
        }
        
        // Close on outside click
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeModal(e);
            }
        });
    }
    
    // Load server-side preview (fallback for unsupported formats like MOV)
    async function loadServerPreview(videoFile, videoElement) {
        console.log('loadServerPreview called for:', videoFile.file.name);
        
        const formData = new FormData();
        formData.append('video_file', videoFile.file);
        formData.append('start_time', videoFile.startTime || 0);
        if (videoFile.endTime !== null) {
            formData.append('end_time', videoFile.endTime);
        }
        
        const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]');
        if (!csrfToken) {
            throw new Error('CSRF token not found');
        }
        formData.append('csrfmiddlewaretoken', csrfToken.value);
        
        console.log('Sending preview request to server...');
        const previewUrl = '{% url "media_converter:video_preview" %}';
        
        const response = await fetch(previewUrl, {
            method: 'POST',
            body: formData,
            credentials: 'same-origin'
        });
        
        console.log('Server response status:', response.status);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Server preview failed: ${response.status}`);
        }
        
        const responseBlob = await response.blob();
        console.log('Received blob size:', responseBlob.size, 'type:', responseBlob.type);
        
        if (responseBlob.size === 0) {
            throw new Error('Preview video is empty');
        }
        
        // Ensure blob has correct MIME type for Safari
        // Safari sometimes has issues if blob type is empty
        let blob = responseBlob;
        if (!blob.type || blob.type === '' || blob.type === 'application/octet-stream') {
            console.log('Fixing blob MIME type to video/mp4');
            blob = new Blob([responseBlob], { type: 'video/mp4' });
        }
        
        // Revoke old URL if exists
        if (videoElement.src && videoElement.src.startsWith('blob:')) {
            URL.revokeObjectURL(videoElement.src);
        }
        if (videoFile.serverPreviewUrl) {
            URL.revokeObjectURL(videoFile.serverPreviewUrl);
        }
        
        const url = URL.createObjectURL(blob);
        console.log('Created blob URL:', url);
        videoFile.serverPreviewUrl = url;
        
        // Set up video element - Safari compatible approach
        videoElement.preload = 'auto';
        videoElement.setAttribute('type', 'video/mp4');
        videoElement.src = url;
        
        // Force display before load
        videoElement.style.display = 'block';
        videoElement.style.visibility = 'visible';
        
        // Safari-specific: remove any existing source elements
        while (videoElement.firstChild) {
            videoElement.removeChild(videoElement.firstChild);
        }
        
        // Safari-compatible loading - use simpler approach
        return new Promise((resolve, reject) => {
            let resolved = false;
            let checkInterval = null;
            let timeoutId = null;
            
            const cleanup = () => {
                if (checkInterval) {
                    clearInterval(checkInterval);
                    checkInterval = null;
                }
                if (timeoutId) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                }
            };
            
            const doResolve = () => {
                if (resolved) return;
                resolved = true;
                cleanup();
                
                if (videoElement.duration && isFinite(videoElement.duration)) {
                    videoFile.duration = videoElement.duration;
                }
                videoElement.style.display = 'block';
                videoElement.style.visibility = 'visible';
                console.log('Video loaded, duration:', videoElement.duration, 'readyState:', videoElement.readyState);
                resolve();
            };
            
            const doReject = (error) => {
                if (resolved) return;
                resolved = true;
                cleanup();
                reject(error);
            };
            
            // Event handlers
            const onCanPlay = () => {
                console.log('canplay event fired');
                doResolve();
            };
            const onLoadedData = () => {
                console.log('loadeddata fired, readyState:', videoElement.readyState);
                if (videoElement.readyState >= 2) doResolve();
            };
            const onLoadedMetadata = () => {
                console.log('loadedmetadata fired, duration:', videoElement.duration);
                // For Safari, loadedmetadata is often enough
                if (videoElement.duration && isFinite(videoElement.duration)) {
                    doResolve();
                }
            };
            const onError = () => {
                console.error('Video error:', videoElement.error);
                doReject(new Error('Video failed to load'));
            };
            
            videoElement.addEventListener('canplay', onCanPlay, { once: true });
            videoElement.addEventListener('loadeddata', onLoadedData, { once: true });
            videoElement.addEventListener('loadedmetadata', onLoadedMetadata, { once: true });
            videoElement.addEventListener('error', onError, { once: true });
            
            // Start loading
            videoElement.load();
            
            // Safari fallback: Poll readyState every 500ms
            // Safari sometimes doesn't fire events properly
            let pollCount = 0;
            checkInterval = setInterval(() => {
                pollCount++;
                console.log(`Poll ${pollCount}: readyState=${videoElement.readyState}, networkState=${videoElement.networkState}, duration=${videoElement.duration}`);
                
                // Check if video has metadata (readyState >= 1) and duration
                if (videoElement.readyState >= 1 && videoElement.duration && isFinite(videoElement.duration)) {
                    console.log('Video has metadata, resolving');
                    doResolve();
                } else if (videoElement.readyState >= 2) {
                    console.log('Video readyState >= 2, resolving');
                    doResolve();
                } else if (videoElement.error) {
                    doReject(new Error('Video loading failed: ' + (videoElement.error.message || 'Unknown error')));
                } else if (videoElement.networkState === 3) {
                    // NETWORK_NO_SOURCE - no valid source
                    doReject(new Error('Video source not supported'));
                }
            }, 500);
            
            // Timeout after 60 seconds (increased for larger files)
            timeoutId = setTimeout(() => {
                if (!resolved) {
                    console.log('Timeout reached. readyState:', videoElement.readyState, 'duration:', videoElement.duration);
                    // If video has any data at all, resolve anyway
                    if (videoElement.readyState >= 1 || (videoElement.duration && isFinite(videoElement.duration))) {
                        console.log('Timeout but video has some data, resolving');
                        doResolve();
                    } else {
                        doReject(new Error('Video load timeout'));
                    }
                }
            }, 60000);
        });
    }
    
    // Cleanup blob URLs when removing videos
    function removeVideo(id) {
        const videoFile = videoFiles.find(vf => String(vf.id) === String(id));
        if (videoFile && videoFile.previewUrl) {
            URL.revokeObjectURL(videoFile.previewUrl);
        }
        videoFiles = videoFiles.filter(vf => vf.id !== id);
        updateVideoList();
    }
});
</script>

<style>
/* Video item transitions */
.video-item {
    transition: opacity 0.2s, border-color var(--transition-base);
}

.video-item:hover {
    border-color: var(--primary-accent) !important;
}

.video-item.dragging {
    opacity: 0.5;
}

/* Modal animations */
@keyframes fadeIn {
    from {
        opacity: 0;
    }
    to {
        opacity: 1;
    }
}

@keyframes slideUp {
    from {
        transform: translateY(20px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

/* Modal Content Styles */
.hybrid-modal-content {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.18);
    padding: 3rem 2rem 2rem 2rem;
    border-radius: 1.5rem;
    max-width: 90vw;
    max-height: 90vh;
    width: 800px;
    overflow-y: auto;
    overflow-x: hidden;
    position: relative;
    box-sizing: border-box;
    box-shadow: 8px 8px 16px rgba(163, 177, 198, 0.6), -8px -8px 16px rgba(255, 255, 255, 0.9);
    touch-action: manipulation;
    -webkit-overflow-scrolling: touch;
    animation: slideUp 0.3s ease;
}

[data-theme="dark"] .hybrid-modal-content {
    background: rgba(26, 26, 46, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 8px 8px 16px rgba(0, 0, 0, 0.5), -8px -8px 16px rgba(40, 40, 60, 0.3);
}

.hybrid-modal-close {
    position: absolute !important;
    top: 1rem !important;
    right: 1rem !important;
    left: auto !important;
    z-index: 100 !important;
    padding: 0.5rem 1rem !important;
    min-width: 44px !important;
    min-height: 44px !important;
    font-size: 1.5rem !important;
    line-height: 1 !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    border-radius: 0.5rem !important;
    cursor: pointer !important;
}

.hybrid-modal-title {
    margin-top: 0;
    margin-bottom: 1.5rem;
    margin-right: 3rem;
    padding-right: 1rem;
    color: var(--text-primary);
    font-size: 1.25rem;
    font-weight: 600;
    word-break: break-word;
}

.hybrid-video-container {
    position: relative;
    margin-bottom: 1.5rem;
    background: var(--bg-base);
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    min-height: 200px;
    max-height: 60vh;
    overflow: hidden;
    border-radius: 1rem;
    box-shadow: inset 4px 4px 8px rgba(163, 177, 198, 0.6), inset -4px -4px 8px rgba(255, 255, 255, 0.9);
}

[data-theme="dark"] .hybrid-video-container {
    box-shadow: inset 4px 4px 8px rgba(0, 0, 0, 0.6), inset -4px -4px 8px rgba(60, 60, 80, 0.3);
}

.hybrid-video-player {
    max-width: 100%;
    max-height: 60vh;
    width: auto;
    height: auto;
    display: block;
    object-fit: contain;
    border-radius: 0.5rem;
    background: #000;
    position: relative;
    z-index: 1;
}

.hybrid-video-error {
    padding: 3rem;
    text-align: center;
    background: rgba(255, 255, 255, 0.25);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    width: 100%;
    border-radius: 1rem;
}

[data-theme="dark"] .hybrid-video-error {
    background: rgba(26, 26, 46, 0.4);
}

.hybrid-video-error .error-title {
    color: var(--text-primary);
    font-weight: 600;
    font-size: 1.125rem;
    margin-bottom: 0.5rem;
}

.hybrid-video-error .error-message {
    font-size: 1rem;
    margin-top: 0.5rem;
    color: var(--text-secondary);
}

.trim-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: rgba(96, 165, 250, 0.3);
    pointer-events: none;
    display: none;
}

.trim-marker {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 3px;
    pointer-events: none;
    display: none;
}

.trim-start {
    background: #10b981;
    box-shadow: 0 0 8px rgba(16, 185, 129, 0.5);
}

.trim-end {
    background: #ef4444;
    box-shadow: 0 0 8px rgba(239, 68, 68, 0.5);
}

.hybrid-modal-inputs {
    display: grid;
    grid-template-columns: 1fr;
    gap: 1.5rem;
    margin-bottom: 1.5rem;
}

.hybrid-modal-inputs .form-label {
    display: block;
    margin-bottom: 0.5rem;
    font-weight: 600;
    color: var(--text-primary);
    font-size: 1rem;
}

.hybrid-modal-inputs .modal-input {
    width: 100%;
    padding: 0.75rem 1rem;
    border: 1px solid rgba(255, 255, 255, 0.18);
    border-radius: 0.75rem;
    font-size: 16px;
    -webkit-appearance: none;
    background: var(--bg-base);
    color: var(--text-primary);
    box-shadow: inset 4px 4px 8px rgba(163, 177, 198, 0.6), inset -4px -4px 8px rgba(255, 255, 255, 0.9);
    transition: box-shadow 0.2s ease, border-color 0.2s ease;
}

[data-theme="dark"] .hybrid-modal-inputs .modal-input {
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: inset 4px 4px 8px rgba(0, 0, 0, 0.6), inset -4px -4px 8px rgba(60, 60, 80, 0.3);
}

.hybrid-modal-inputs .modal-input:focus {
    outline: none;
    box-shadow: 8px 8px 16px rgba(163, 177, 198, 0.6), -8px -8px 16px rgba(255, 255, 255, 0.9);
    border-color: #60A5FA;
}

[data-theme="dark"] .hybrid-modal-inputs .modal-input:focus {
    box-shadow: 8px 8px 16px rgba(0, 0, 0, 0.5), -8px -8px 16px rgba(40, 40, 60, 0.3);
}

.hybrid-modal-inputs .modal-input::placeholder {
    color: var(--text-secondary);
    opacity: 0.7;
}

.hybrid-modal-inputs .modal-btn {
    margin-top: 0.75rem;
    width: 100%;
    font-size: 16px;
    font-weight: 600;
}

.hybrid-modal-tip {
    margin-bottom: 1.5rem;
    padding: 1rem;
    background: rgba(255, 255, 255, 0.25);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 0.75rem;
    border: 1px solid rgba(255, 255, 255, 0.18);
}

[data-theme="dark"] .hybrid-modal-tip {
    background: rgba(26, 26, 46, 0.4);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.hybrid-modal-tip p {
    margin: 0;
    font-size: 0.875rem;
    color: var(--text-secondary);
    line-height: 1.6;
}

.hybrid-modal-tip strong {
    color: var(--text-primary);
}

.hybrid-modal-actions {
    display: flex;
    gap: 1rem;
    justify-content: flex-end;
    margin-top: 1.5rem;
    padding-top: 1rem;
    border-top: 1px solid rgba(255, 255, 255, 0.18);
}

[data-theme="dark"] .hybrid-modal-actions {
    border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.hybrid-apply-btn {
    padding: 0.75rem 2rem;
    font-size: 16px;
    min-height: 44px;
    font-weight: 600;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
}

/* Mobile responsive adjustments */
@media (max-width: 768px) {
    .video-item {
        padding: 0.75rem !important;
    }
    
    .video-item > div:first-child {
        flex-direction: column;
        align-items: stretch !important;
        gap: 0.75rem !important;
    }
    
    .video-item > div:first-child > div:first-of-type {
        width: 100%;
        min-width: 0;
    }
    
    .video-item-buttons {
        width: 100% !important;
        display: flex !important;
        justify-content: stretch !important;
        gap: 0.5rem !important;
        margin-top: 0.5rem !important;
    }
    
    .video-item > div:first-child > div:last-child {
        width: 100% !important;
        display: flex !important;
        justify-content: stretch !important;
        gap: 0.5rem !important;
        margin-top: 0.5rem !important;
    }
    
    .video-time-inputs {
        grid-template-columns: 1fr !important;
    }
    
    .hybrid-modal-content {
        width: 95vw !important;
        max-width: 95vw !important;
        padding: 2.5rem 1rem 1.5rem 1rem !important;
        margin: 0.5rem !important;
    }
    
    .hybrid-modal-close {
        top: 0.5rem !important;
        right: 0.5rem !important;
        padding: 0.5rem !important;
        min-width: 40px !important;
        min-height: 40px !important;
        font-size: 1.25rem !important;
    }
    
    .hybrid-modal-title {
        font-size: 1.125rem !important;
        margin-right: 3rem !important;
        margin-top: 0 !important;
    }
    
    .hybrid-modal-inputs {
        grid-template-columns: 1fr !important;
    }
    
    .hybrid-apply-btn {
        width: 100% !important;
    }
    
    .hybrid-video-player {
        width: 100% !important;
        max-width: 100% !important;
    }
    
    .preview-video-btn,
    .remove-video-btn {
        flex: 1;
        min-width: 0;
        width: 100%;
        padding: 0.75rem 1rem !important;
        font-size: 16px !important;
        min-height: 44px !important;
        -webkit-tap-highlight-color: transparent !important;
        touch-action: manipulation !important;
    }
}

/* Dark mode compatibility */
[data-theme="dark"] #videoPreviewModal {
    background: rgba(15, 23, 42, 0.85);
}

/* Merge Progress Modal - Theme Aware */
.merge-progress-modal {
    margin-top: 1rem;
    padding: 1.5rem;
    background: var(--glass-bg);
    backdrop-filter: var(--glass-blur);
    -webkit-backdrop-filter: var(--glass-blur);
    border: 1px solid var(--glass-border);
    border-radius: var(--radius-lg);
    box-shadow: var(--neu-shadow);
    text-align: center;
}

.merge-progress-title {
    margin-bottom: 1rem;
    color: var(--text-primary);
    font-size: 1rem;
}

.merge-progress-title strong {
    color: var(--text-primary);
    font-weight: 600;
}

.merge-progress-bar-container {
    width: 100%;
    height: 10px;
    background: rgba(0, 0, 0, 0.1);
    border-radius: var(--radius-sm);
    overflow: hidden;
    box-shadow: inset 2px 2px 4px rgba(0, 0, 0, 0.1);
}

[data-theme="dark"] .merge-progress-bar-container {
    background: rgba(255, 255, 255, 0.1);
    box-shadow: inset 2px 2px 4px rgba(0, 0, 0, 0.3);
}

.merge-progress-bar {
    width: 0%;
    height: 100%;
    background: linear-gradient(90deg, var(--primary-accent), var(--secondary-accent));
    transition: width 0.3s ease;
    box-shadow: 0 0 10px rgba(96, 165, 250, 0.5);
}

.merge-progress-text {
    margin-top: 0.75rem;
    font-size: 0.9rem;
    color: var(--text-secondary);
}

/* Remove button styling is now handled by hybrid-style.css */
</style>
{% endblock %}
{% endblock %}
